<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChartVault ‚Äì Billboard Hot 100 & Billboard 200 Archive</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,500;0,9..40,700;0,9..40,800;1,9..40,400&family=DM+Mono:wght@400;500&family=Playfair+Display:ital,wght@0,700;0,900;1,700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
:root{--gold:#d4af37;--gold-dim:#d4af3744;--bg:#0a0a0a;--bg2:#111;--bg3:#141414;--border:#1a1a1a;--border2:#2a2a2a;--text:#e0e0e0;--text-dim:#888;--text-faint:#555;--text-ghost:#333;--up:#4ade80;--down:#f87171;--same:#666;--new:#fbbf24}
*{box-sizing:border-box;margin:0;padding:0}
body{min-height:100vh;background:linear-gradient(160deg,var(--bg),var(--bg2) 40%,#0d0d0d);color:var(--text);font-family:'DM Sans','Helvetica Neue',sans-serif;-webkit-font-smoothing:antialiased}
::selection{background:var(--gold-dim);color:#fff}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:#333;border-radius:3px}
input:focus,select:focus{outline:none}
a{color:var(--gold);text-decoration:none}

.header{padding:28px 24px 20px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,rgba(212,175,55,.03),transparent)}
.header-inner{max-width:960px;margin:0 auto}
.logo-row{display:flex;align-items:baseline;gap:12px;flex-wrap:wrap}
.logo{font-family:'Playfair Display',serif;font-size:32px;font-weight:900;color:var(--gold);letter-spacing:-.5px}
.tagline{font-size:11px;color:var(--text-faint);font-family:'DM Mono',monospace;letter-spacing:2px;text-transform:uppercase}
.nav{display:flex;gap:4px;margin-top:20px;flex-wrap:wrap}
.nav-btn{padding:8px 18px;border-radius:8px;border:none;background:rgba(255,255,255,.04);color:var(--text-dim);font-weight:500;font-size:13px;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .2s}
.nav-btn.active{background:var(--gold);color:#111;font-weight:700}
.nav-btn:hover:not(.active){background:rgba(255,255,255,.08)}

.main{max-width:960px;margin:0 auto;padding:24px}
.view{display:none}.view.active{display:block}

.load-msg{font-size:12px;color:var(--text-faint);font-family:'DM Mono',monospace;margin-bottom:12px;display:none}
.load-msg.visible{display:block}
.load-bar-wrap{background:#1a1a1a;border-radius:8px;height:6px;margin-bottom:20px;overflow:hidden;display:none}
.load-bar-wrap.visible{display:block}
.load-bar{height:100%;background:var(--gold);border-radius:8px;transition:width .3s;width:0%}

.selectors{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:20px}
.sel-group{flex:1 1 200px}
.sel-label{font-size:11px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;display:block;margin-bottom:6px}
.sel-input,.sel-select{width:100%;padding:10px 14px;border-radius:8px;border:1px solid var(--border2);background:var(--bg3);color:var(--text);font-size:14px;font-family:'DM Sans',sans-serif}
select{cursor:pointer}

.jump-btns{display:flex;gap:5px;margin-bottom:20px;flex-wrap:wrap;align-items:center}
.jump-label{font-size:12px;color:var(--text-faint);margin-right:4px}
.jump-btn{padding:5px 12px;border-radius:6px;border:1px solid var(--border2);background:var(--bg3);color:var(--text-dim);font-size:11px;font-weight:600;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .15s}
.jump-btn:hover{border-color:var(--gold);color:var(--gold)}
.jump-btn.active{background:var(--gold);color:#111;border-color:var(--gold)}

.arrow-btn{padding:10px 14px;border:1px solid var(--border2);background:var(--bg3);color:var(--text-dim);font-size:16px;cursor:pointer;transition:all .15s}
.arrow-btn:hover{color:var(--gold);border-color:var(--gold)}
.arrow-btn:first-child{border-radius:8px 0 0 8px}
.arrow-btn:last-child{border-radius:0 8px 8px 0;border-left:none}

.chart-header{background:linear-gradient(135deg,rgba(212,175,55,.08),rgba(212,175,55,.02));border:1px solid #222;border-radius:14px;padding:20px 24px;margin-bottom:16px}
.chart-title{font-family:'Playfair Display',serif;font-size:24px;font-weight:700;color:#fff}
.chart-date{font-size:14px;color:var(--text-dim);margin-top:4px}
.chart-count{font-size:13px;color:var(--text-faint);margin-top:8px;font-family:'DM Mono',monospace}
.chart-legend{display:flex;gap:20px;margin-top:12px;font-size:11px;color:var(--text-faint);flex-wrap:wrap}

.show-more-wrap{text-align:center;padding:16px}
.show-more-btn{padding:10px 32px;border-radius:8px;border:1px solid var(--border2);background:var(--bg3);color:var(--gold);font-size:13px;font-weight:600;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .15s}
.show-more-btn:hover{background:var(--gold);color:#111}

.chart-list{background:var(--bg2);border:1px solid var(--border);border-radius:14px;overflow:hidden}
.chart-entry{display:flex;align-items:center;gap:14px;padding:10px 16px;transition:background .15s;cursor:default;opacity:0;transform:translateY(6px);animation:fadeIn .3s forwards}
.chart-entry:hover{background:rgba(255,255,255,.04)}
.chart-divider{height:1px;background:var(--border);margin:0 16px}
@keyframes fadeIn{to{opacity:1;transform:translateY(0)}}

.rank-badge{width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:13px;font-family:'DM Mono',monospace;flex-shrink:0}
.rank-badge.gold{background:var(--gold);color:#111;width:42px;height:42px;font-weight:800;font-size:15px;box-shadow:0 2px 12px #d4af3744}
.rank-badge.silver{background:#c0c0c0;color:#111;font-weight:800}
.rank-badge.bronze{background:#cd7f32;color:#111;font-weight:800}
.rank-badge.top10{background:rgba(255,255,255,.08);color:#ccc}
.rank-badge.normal{background:rgba(255,255,255,.04);color:#888;font-weight:500;font-size:12px}

.entry-info{flex:1;min-width:0}
.entry-title{font-weight:700;font-size:15px;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.entry-title.clickable:hover{text-decoration:underline;text-decoration-color:var(--gold);cursor:pointer}
.entry-meta{display:flex;align-items:center;gap:8px;margin-top:2px;flex-wrap:wrap}
.entry-artist{font-size:13px;color:var(--gold);cursor:pointer;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.entry-artist:hover{text-decoration:underline}
.entry-stats{display:flex;align-items:center;gap:12px;flex-shrink:0;font-size:12px}
.stat-col{text-align:center;min-width:28px}
.stat-header{color:var(--text-faint);font-size:10px;text-transform:uppercase;letter-spacing:.5px}
.stat-val{color:#999}
.movement{font-size:14px;width:20px;text-align:center}
.chart-badge{font-size:10px;color:#666;background:rgba(255,255,255,.04);padding:3px 8px;border-radius:10px;white-space:nowrap}

.search-wrap{position:relative;margin-bottom:20px}
.search-input{width:100%;padding:14px 20px;border-radius:12px;border:1px solid var(--border2);background:var(--bg3);color:var(--text);font-size:16px;font-family:'DM Sans',sans-serif}
.search-filters{display:flex;gap:4px;margin-top:8px}
.filter-btn{padding:5px 10px;border-radius:6px;border:none;background:rgba(255,255,255,.06);color:var(--text-dim);font-size:11px;font-weight:600;cursor:pointer;text-transform:uppercase;letter-spacing:.5px;font-family:'DM Sans',sans-serif;transition:all .15s}
.filter-btn.active{background:var(--gold);color:#111}
.result-count{font-size:13px;color:var(--text-faint);margin-bottom:16px;font-family:'DM Mono',monospace}

.artist-header{background:linear-gradient(135deg,rgba(212,175,55,.12),rgba(212,175,55,.02));border:1px solid #222;border-radius:16px;padding:28px;margin-bottom:20px;position:relative;overflow:hidden}
.artist-header::before{content:'';position:absolute;top:-40px;right:-40px;width:200px;height:200px;background:radial-gradient(circle,rgba(212,175,55,.08),transparent 70%);pointer-events:none}
.artist-name{font-family:'Playfair Display',serif;font-size:32px;font-weight:900;color:var(--gold);letter-spacing:-.5px}
.artist-years{font-size:13px;color:var(--text-dim);margin-top:4px;font-family:'DM Mono',monospace}

.stat-cards{display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-top:20px}
.stat-card{background:rgba(255,255,255,.03);border:1px solid #222;border-radius:12px;padding:16px;text-align:center;transition:all .2s}
.stat-card:hover{border-color:var(--gold-dim);background:rgba(212,175,55,.04)}
.stat-card-icon{font-size:24px;margin-bottom:6px}
.stat-card-val{font-size:28px;font-weight:800;color:#fff;font-family:'DM Mono',monospace}
.stat-card-val.gold-text{color:var(--gold)}
.stat-card-label{font-size:10px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;margin-top:2px}

.timeline-section{margin-bottom:20px;padding:16px 20px;background:var(--bg2);border:1px solid var(--border);border-radius:12px}
.timeline-title{font-size:12px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;margin-bottom:12px}
.timeline-bar{position:relative;height:32px;background:rgba(255,255,255,.03);border-radius:8px;overflow:hidden}
.timeline-active{position:absolute;height:100%;background:linear-gradient(90deg,var(--gold),#e8c547);border-radius:8px;min-width:4px}
.timeline-labels{display:flex;justify-content:space-between;margin-top:6px;font-size:10px;color:var(--text-faint);font-family:'DM Mono',monospace}
.timeline-dots{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
.timeline-dot{position:absolute;top:50%;width:8px;height:8px;background:#fff;border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 6px rgba(212,175,55,.5)}
.timeline-dot.no1{background:var(--gold);width:12px;height:12px;box-shadow:0 0 10px rgba(212,175,55,.8)}

.peak-chart{margin-bottom:20px;padding:20px;background:var(--bg2);border:1px solid var(--border);border-radius:12px}
.peak-chart-title{font-size:12px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;margin-bottom:12px}
.peak-chart svg{width:100%;overflow:visible}
.chart-tooltip{position:absolute;pointer-events:none;background:#1a1a1a;border:1px solid var(--gold-dim);border-radius:6px;padding:6px 10px;font-size:11px;font-family:'DM Mono',monospace;color:#ccc;white-space:nowrap;z-index:100;opacity:0;transition:opacity .15s;box-shadow:0 4px 12px rgba(0,0,0,.5);max-width:260px}
.chart-tooltip.visible{opacity:1}
.chart-tooltip .tt-rank{color:var(--gold);font-weight:700;font-size:13px}
.chart-tooltip .tt-date{color:#888;font-size:10px}
.peak-chart{position:relative}

.decade-group{margin-bottom:24px}
.decade-header{display:flex;align-items:center;gap:12px;margin-bottom:12px;padding:0 4px}
.decade-label{font-family:'Playfair Display',serif;font-size:22px;font-weight:700;color:var(--gold)}
.decade-line{flex:1;height:1px;background:linear-gradient(90deg,var(--gold-dim),transparent)}
.decade-count{font-size:11px;color:var(--text-faint);font-family:'DM Mono',monospace}

.artist-stats-row{display:flex;gap:24px;margin-top:16px;flex-wrap:wrap}
.artist-stat-val{font-size:24px;font-weight:800;color:var(--gold);font-family:'DM Mono',monospace}
.artist-stat-label{font-size:11px;color:var(--text-faint);text-transform:uppercase;letter-spacing:.5px}
.no1-tag{font-size:10px;color:var(--gold);font-weight:700;letter-spacing:1px}
.sort-label{font-size:12px;color:var(--text-faint);margin-bottom:10px;font-family:'DM Mono',monospace}

.empty{text-align:center;padding:60px 24px;color:var(--text-faint);background:var(--bg2);border-radius:14px;border:1px solid var(--border)}
.empty-icon{font-size:48px;margin-bottom:12px}
.empty p{font-size:15px;color:#666}
.empty .sub{font-size:13px;margin-top:6px;color:#444}

.info-box{padding:16px 20px;background:rgba(212,175,55,.04);border:1px solid #222;border-radius:12px;margin-bottom:20px}
.info-box h3{font-size:14px;color:var(--gold);margin-bottom:4px}
.info-box p{font-size:13px;color:var(--text-dim);line-height:1.6}

.preload-section{margin-bottom:20px;padding:16px 20px;background:var(--bg2);border:1px solid var(--border);border-radius:12px}
.preload-section h3{font-size:14px;color:#fff;margin-bottom:8px}
.preload-section p{font-size:12px;color:var(--text-faint);margin-bottom:12px}
.preload-btns{display:flex;gap:8px;flex-wrap:wrap}
.preload-btn{padding:8px 16px;border-radius:8px;border:1px solid var(--border2);background:var(--bg3);color:var(--text);font-size:13px;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .15s}
.preload-btn:hover{border-color:var(--gold);color:var(--gold)}
.preload-btn:disabled{opacity:.4;cursor:default}
.preload-btn.done{border-color:#333;color:#4ade80;opacity:.7}

.cache-info{margin-top:10px;font-size:11px;color:var(--text-faint);font-family:'DM Mono',monospace}
.clear-btn{padding:4px 10px;border-radius:4px;border:1px solid #333;background:transparent;color:#666;font-size:11px;cursor:pointer;font-family:'DM Sans',sans-serif;margin-left:8px}
.clear-btn:hover{border-color:var(--down);color:var(--down)}

.narrative{padding:16px 20px;background:rgba(212,175,55,.04);border:1px solid #1f1f1f;border-radius:12px;margin-bottom:20px;line-height:1.7}
.narrative.enrichment{background:transparent;border:1px solid rgba(212,175,55,.12);margin-top:-12px;padding:14px 20px;font-size:13px;color:var(--text-dim)}
.narrative p{font-size:14px;color:var(--text-dim);margin:0}
.narrative strong{color:#ccc}
.narrative .gld{color:var(--gold);font-weight:700}

.artist-hero{display:flex;gap:24px;align-items:flex-start}
.artist-photo-wrap{flex-shrink:0;width:140px;height:140px;border-radius:14px;overflow:hidden;background:rgba(255,255,255,.03);border:1px solid #222;display:none}
.artist-photo-wrap.loaded{display:block}
.artist-photo-wrap img{width:100%;height:100%;object-fit:cover}
.artist-info-side{flex:1;min-width:0}

.song-hero{display:flex;gap:20px;align-items:flex-start}
.song-art-wrap{flex-shrink:0;width:120px;height:120px;border-radius:10px;overflow:hidden;background:rgba(255,255,255,.03);border:1px solid #222;display:none;box-shadow:0 4px 20px rgba(0,0,0,.4);position:relative}
.song-art-wrap.loaded{display:block}
.song-art-wrap img{width:100%;height:100%;object-fit:cover}

.song-info-side{flex:1;min-width:0}

.credits-section{padding:16px 20px;background:var(--bg2);border:1px solid var(--border);border-radius:12px;margin-bottom:20px}
.credits-section.loading{opacity:.6}
.credits-title{font-size:12px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
.credits-row{display:flex;gap:8px;margin-bottom:8px;align-items:baseline;flex-wrap:wrap}
.credits-label{font-size:11px;color:var(--text-faint);text-transform:uppercase;letter-spacing:.5px;min-width:80px;flex-shrink:0}
.credits-names{font-size:14px;color:var(--text);line-height:1.5}
.credits-names span{color:var(--gold)}
.credit-name{cursor:pointer;transition:opacity .15s}.credit-name:hover{opacity:.7}
.credit-attr{color:var(--text-faint)!important;font-size:12px}
.sw-section{margin-top:24px;padding:20px;background:var(--bg2);border:1px solid var(--border);border-radius:14px}
.sw-header{display:flex;justify-content:space-between;align-items:baseline;flex-wrap:wrap;gap:4px;margin-bottom:16px}
.sw-title{font-size:16px;font-weight:700;color:var(--gold)}
.sw-subtitle{font-size:12px;color:var(--text-dim)}
.sw-status{font-size:12px;color:var(--text-faint);margin-top:8px}
.sw-grid{display:flex;flex-direction:column;gap:2px}
.sw-card{display:flex;align-items:center;gap:12px;padding:10px 12px;border-radius:8px;cursor:pointer;transition:background .15s}
.sw-card:hover{background:rgba(255,255,255,.04)}
.sw-card-gold{background:rgba(212,175,55,.06)}
.sw-card-rank{font-size:16px;font-weight:700;min-width:42px;text-align:center}
.sw-card-info{flex:1;min-width:0}
.sw-card-title{font-size:14px;font-weight:600;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sw-card-artist{font-size:12px;color:var(--text-dim)}
.sw-card-roles{font-size:11px;color:var(--gold);opacity:.7;margin-top:1px}
.sw-card-weeks{font-size:14px;font-weight:600;color:var(--text-dim);text-align:right;min-width:40px}
.sw-card-weeks span{font-size:10px;display:block;color:var(--text-faint);font-weight:400}
.sw-source{font-size:10px;color:var(--text-ghost);margin-top:12px}
.tracklist-section{padding:20px;background:var(--bg2);border:1px solid var(--border);border-radius:12px;margin-bottom:20px}
.tracklist-section.loading{opacity:.6}
.tracklist-title{font-size:12px;color:var(--text-faint);text-transform:uppercase;letter-spacing:1px;margin-bottom:14px;display:flex;align-items:center;gap:8px}
.tracklist-title .track-count{font-size:11px;color:#555;font-weight:400}
/* ‚îÄ‚îÄ‚îÄ ALBUM LINK (from LP) ‚îÄ‚îÄ‚îÄ */
.song-album-link{background:linear-gradient(135deg,rgba(100,60,180,.06),rgba(212,175,55,.04));border:1px solid var(--border);border-radius:12px;padding:16px 18px;margin-bottom:16px;display:flex;align-items:center;gap:14px;cursor:pointer;transition:all .2s}
.song-album-link:hover{border-color:rgba(212,175,55,.2);background:linear-gradient(135deg,rgba(100,60,180,.08),rgba(212,175,55,.06));transform:translateX(2px)}
.song-album-art{width:56px;height:56px;border-radius:6px;background:var(--bg3);overflow:hidden;flex-shrink:0;display:flex;align-items:center;justify-content:center;font-size:24px}
.song-album-art img{width:100%;height:100%;object-fit:cover}
.song-album-info{flex:1;min-width:0}
.song-album-label{font-size:10px;color:var(--gold);text-transform:uppercase;letter-spacing:1.2px;font-weight:700;margin-bottom:3px}
.song-album-name{font-size:15px;font-weight:700;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.song-album-meta{font-size:11px;color:var(--text-faint);margin-top:2px}
.song-album-arrow{color:var(--text-faint);font-size:18px;flex-shrink:0;transition:transform .2s}
.song-album-link:hover .song-album-arrow{transform:translateX(3px);color:var(--gold)}
@media(max-width:600px){
  .song-album-link{padding:12px 14px;gap:10px}
  .song-album-art{width:48px;height:48px}
  .song-album-name{font-size:14px}
}
/* ‚îÄ‚îÄ‚îÄ ALBUM SINGLES ‚îÄ‚îÄ‚îÄ */
.album-singles-section{background:linear-gradient(135deg,rgba(212,175,55,.04),rgba(60,130,180,.04));border:1px solid var(--border);border-radius:14px;padding:22px;margin-bottom:16px;position:relative;overflow:hidden}
.album-singles-section::before{content:'';position:absolute;top:-30px;left:-30px;width:120px;height:120px;background:radial-gradient(circle,rgba(212,175,55,.06),transparent 70%);pointer-events:none}
.album-singles-title{font-size:15px;font-weight:700;color:var(--gold);margin-bottom:14px;display:flex;align-items:center;gap:8px;letter-spacing:.3px}
.album-singles-title .as-sub{font-size:11px;font-weight:400;color:var(--text-faint);margin-left:auto}
.album-single-card{display:flex;align-items:center;gap:14px;padding:12px 14px;border-radius:10px;background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);cursor:pointer;transition:all .2s;margin-bottom:6px}
.album-single-card:last-child{margin-bottom:0}
.album-single-card:hover{border-color:rgba(212,175,55,.2);background:rgba(212,175,55,.04);transform:translateX(2px)}
.album-single-card.as-no1{background:linear-gradient(135deg,rgba(212,175,55,.1),rgba(212,175,55,.03));border-color:rgba(212,175,55,.2)}
.as-peak{font-family:'DM Mono',monospace;font-size:22px;font-weight:800;min-width:44px;text-align:center;line-height:1}
.as-peak.as-peak-1{color:var(--gold);text-shadow:0 0 12px rgba(212,175,55,.3)}
.as-peak.as-peak-top5{color:#e0e0e0}
.as-peak.as-peak-top10{color:#cd7f32}
.as-peak.as-peak-top20{color:var(--text-dim)}
.as-peak.as-peak-deep{color:var(--text-faint)}
.as-info{flex:1;min-width:0}
.as-title{font-size:14px;font-weight:700;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.as-meta{font-size:11px;color:var(--text-faint);margin-top:2px;display:flex;gap:12px}
.as-badge{font-size:9px;font-weight:700;padding:2px 6px;border-radius:4px;background:rgba(212,175,55,.12);color:var(--gold);letter-spacing:.5px;align-self:center;flex-shrink:0}
.as-badge.as-badge-1{background:rgba(212,175,55,.2)}
@media(max-width:600px){
  .album-singles-section{padding:16px}
  .as-peak{font-size:19px;min-width:36px}
  .as-title{font-size:13px}
}
.track-item{display:flex;align-items:center;gap:12px;padding:8px 4px;border-bottom:1px solid rgba(255,255,255,.03)}
.track-item:last-child{border-bottom:none}
.track-num{font-size:12px;color:#555;font-family:'DM Mono',monospace;width:22px;text-align:right;flex-shrink:0}
.track-name{font-size:14px;color:var(--text);flex:1}
.track-duration{font-size:12px;color:#555;font-family:'DM Mono',monospace;flex-shrink:0}
.track-disc-label{font-size:11px;color:var(--gold);text-transform:uppercase;letter-spacing:1px;padding:10px 0 4px;margin-top:4px;border-top:1px solid rgba(212,175,55,.15)}
.album-meta-row{display:flex;flex-wrap:wrap;gap:16px;margin-bottom:14px;font-size:13px;color:var(--text-dim)}
.album-meta-row span{color:var(--text-faint);font-size:11px;text-transform:uppercase;letter-spacing:.3px;margin-right:4px}

@media(max-width:600px){
  .artist-hero{flex-direction:column;align-items:center;text-align:center}
  .artist-photo-wrap{width:110px;height:110px}
  .song-hero{flex-direction:column;align-items:center;text-align:center}
  .song-art-wrap{width:100px;height:100px}
  .stat-cards{justify-items:center}
  .song-stats-row{justify-content:center}
}

.song-header{background:linear-gradient(135deg,rgba(212,175,55,.1),rgba(212,175,55,.02));border:1px solid #222;border-radius:14px;padding:24px;margin-bottom:16px}
.artist-entry-nav{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:16px;padding:10px 0}
.entry-nav-btn{display:flex;align-items:center;gap:6px;background:none;border:1px solid var(--border2);border-radius:8px;padding:8px 12px;color:var(--text-dim);font-size:12px;font-family:inherit;cursor:pointer;transition:all .2s;max-width:42%;overflow:hidden}
.entry-nav-btn:hover{border-color:var(--gold-dim);color:var(--gold);background:rgba(212,175,55,.05)}
.entry-nav-arrow{font-size:18px;line-height:1;color:var(--gold);flex-shrink:0}
.entry-nav-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.entry-nav-next{text-align:right}
.entry-nav-pos{font-size:11px;color:var(--text-faint);white-space:nowrap;cursor:pointer;flex-shrink:0}
.entry-nav-pos:hover{color:var(--gold)}
.entry-nav-spacer{flex:1}
.song-title-big{font-family:'Playfair Display',serif;font-size:26px;font-weight:900;color:#fff}
.song-artist-big{font-size:16px;color:var(--gold);margin-top:4px;cursor:pointer}
.song-artist-big:hover{text-decoration:underline}
.song-stats-row{display:flex;gap:24px;margin-top:16px;flex-wrap:wrap}
.back-btn{display:inline-flex;align-items:center;gap:6px;padding:6px 14px;border-radius:6px;border:1px solid var(--border2);background:var(--bg3);color:var(--text-dim);font-size:12px;cursor:pointer;font-family:'DM Sans',sans-serif;margin-bottom:16px;transition:all .15s}
.back-btn:hover{border-color:var(--gold);color:var(--gold)}
.week-row{display:flex;align-items:center;gap:14px;padding:10px 16px;opacity:0;transform:translateY(6px);animation:fadeIn .3s forwards}
.week-row:hover{background:rgba(255,255,255,.04)}
.week-date{font-size:13px;color:var(--text-dim);min-width:140px;cursor:pointer;font-family:'DM Mono',monospace}
.week-date:hover{color:var(--gold);text-decoration:underline}
/* Companion entries: other songs by same artist charting that week */
.week-companions{display:flex;flex-wrap:wrap;gap:4px;margin-left:auto;flex-shrink:1;min-width:0;justify-content:flex-end}
.companion-pill{font-size:10px;padding:2px 7px;border-radius:10px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);color:#777;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:180px;cursor:pointer;transition:all .15s;line-height:1.4}
.companion-pill:hover{background:rgba(212,175,55,.1);border-color:rgba(212,175,55,.2);color:var(--gold)}
.companion-pill .comp-rank{font-weight:700;color:#999;margin-right:3px;font-family:'DM Mono',monospace}
.companion-pill:hover .comp-rank{color:var(--gold)}
@media(max-width:600px){
  .week-companions{display:none}
}
/* ‚îÄ‚îÄ‚îÄ DATE PICKER ‚îÄ‚îÄ‚îÄ */
.date-picker-wrap{position:relative}
.date-picker-btn{width:100%;padding:10px 14px;border-radius:8px;border:1px solid var(--border2);background:var(--bg3);color:#fff;font-size:14px;font-family:'DM Mono',monospace;cursor:pointer;text-align:left;transition:all .15s;display:flex;align-items:center;justify-content:space-between}
.date-picker-btn:hover{border-color:var(--gold)}
.date-picker-btn .dp-arrow{font-size:10px;color:#555;transition:transform .2s}
.date-picker-btn.open .dp-arrow{transform:rotate(180deg)}
.date-picker-panel{position:absolute;top:calc(100% + 4px);left:0;right:0;background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:12px;z-index:50;display:none;box-shadow:0 8px 32px rgba(0,0,0,.5);max-height:320px;overflow-y:auto}
.date-picker-panel.open{display:block}
.dp-month-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px}
.dp-month-btn{padding:7px 4px;border-radius:6px;border:1px solid transparent;background:rgba(255,255,255,.04);color:var(--text-dim);font-size:12px;font-weight:600;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .15s;text-align:center}
.dp-month-btn:hover{border-color:var(--gold);color:var(--gold)}
.dp-month-btn.active{background:var(--gold);color:#111;border-color:var(--gold)}
.dp-month-btn.disabled{opacity:.25;pointer-events:none}
.dp-week-list{display:flex;flex-direction:column;gap:2px}
.dp-week-btn{padding:8px 12px;border-radius:6px;border:none;background:transparent;color:var(--text-dim);font-size:13px;cursor:pointer;font-family:'DM Mono',monospace;text-align:left;transition:all .12s;display:flex;justify-content:space-between;align-items:center}
.dp-week-btn:hover{background:rgba(212,175,55,.1);color:var(--gold)}
.dp-week-btn.active{background:rgba(212,175,55,.15);color:var(--gold);font-weight:700}
.dp-week-btn .dp-wk-num{font-size:10px;color:#555}
/* ‚îÄ‚îÄ‚îÄ #1 HERO ‚îÄ‚îÄ‚îÄ */
.no1-hero{display:flex;align-items:center;gap:16px;padding:16px;margin:12px 0 8px;border-radius:12px;background:linear-gradient(135deg,rgba(212,175,55,.08),rgba(212,175,55,.02));border:1px solid rgba(212,175,55,.12)}
.no1-hero-art{width:80px;height:80px;border-radius:8px;overflow:hidden;background:rgba(255,255,255,.03);flex-shrink:0;border:1px solid rgba(212,175,55,.2);box-shadow:0 2px 12px rgba(0,0,0,.3);position:relative}
.no1-hero-art img{width:100%;height:100%;object-fit:cover}

.no1-hero-info{flex:1;min-width:0}
.no1-hero-label{font-size:10px;font-weight:700;color:var(--gold);text-transform:uppercase;letter-spacing:1px;margin-bottom:2px}
.no1-hero-title{font-size:18px;font-weight:800;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:pointer}
.no1-hero-title:hover{text-decoration:underline;text-decoration-color:var(--gold)}
.no1-hero-artist{font-size:14px;color:var(--gold);cursor:pointer}
.no1-hero-artist:hover{text-decoration:underline}
.no1-hero-stat{font-size:11px;color:var(--text-faint);margin-top:4px}
/* ‚îÄ‚îÄ‚îÄ SHARE ‚îÄ‚îÄ‚îÄ */
.share-btn{padding:5px 12px;border-radius:6px;border:1px solid var(--border2);background:var(--bg3);color:var(--text-dim);font-size:12px;cursor:pointer;transition:all .15s;font-family:'DM Sans',sans-serif;white-space:nowrap}
.share-btn:hover{border-color:var(--gold);color:var(--gold);background:rgba(212,175,55,.06)}
.share-btn:active{transform:scale(.96)}
.share-btn.copied{border-color:var(--up);color:var(--up);background:rgba(76,175,80,.06)}
/* ‚îÄ‚îÄ‚îÄ CHART PEAKS ‚îÄ‚îÄ‚îÄ */
.chart-peaks-section{background:linear-gradient(135deg,rgba(212,175,55,.04),rgba(100,60,180,.04));border:1px solid var(--border);border-radius:14px;padding:22px;margin-bottom:16px;position:relative;overflow:hidden}
.chart-peaks-section::before{content:'';position:absolute;top:-30px;right:-30px;width:120px;height:120px;background:radial-gradient(circle,rgba(212,175,55,.06),transparent 70%);pointer-events:none}
.chart-peaks-title{font-size:15px;font-weight:700;color:var(--gold);margin-bottom:14px;display:flex;align-items:center;gap:8px;letter-spacing:.3px}
.chart-peaks-title .cp-sub{font-size:11px;font-weight:400;color:var(--text-faint);margin-left:auto}
.chart-peaks-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(190px,1fr));gap:8px}
.chart-peak-card{display:flex;align-items:center;gap:12px;padding:11px 14px;border-radius:10px;background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);transition:all .2s;position:relative;overflow:hidden}
.chart-peak-card:hover{border-color:rgba(212,175,55,.2);background:rgba(212,175,55,.04);transform:translateY(-1px)}
.chart-peak-card.peak-card-1{background:linear-gradient(135deg,rgba(212,175,55,.1),rgba(212,175,55,.03));border-color:rgba(212,175,55,.2)}
.chart-peak-card.peak-card-1::after{content:'üëë';position:absolute;top:4px;right:6px;font-size:10px;opacity:.5}
.chart-peak-pos{font-family:'DM Mono',monospace;font-size:22px;font-weight:800;min-width:38px;text-align:center;line-height:1}
.chart-peak-pos.peak-1{color:var(--gold);text-shadow:0 0 12px rgba(212,175,55,.3)}
.chart-peak-pos.peak-top5{color:#e0e0e0}
.chart-peak-pos.peak-top10{color:#cd7f32}
.chart-peak-pos.peak-top20{color:var(--text-dim)}
.chart-peak-pos.peak-deep{color:var(--text-faint)}
.chart-peak-name{font-size:12px;line-height:1.35;min-width:0}
.chart-peak-name .cp-main{font-weight:600;color:var(--text);display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.chart-peak-name .cp-note{display:block;font-size:10px;color:var(--text-faint);font-style:italic;margin-top:1px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.chart-peak-name .cp-aka{font-size:10px;color:var(--text-ghost);font-style:italic;margin-top:1px}
.chart-peaks-source{font-size:10px;color:var(--text-ghost);margin-top:12px;padding-top:10px;border-top:1px solid rgba(255,255,255,.04)}
.chart-peaks-source a{color:var(--text-faint);text-decoration:none}
.chart-peaks-source a:hover{color:var(--gold);text-decoration:underline}
@media(max-width:600px){
  .chart-peaks-grid{grid-template-columns:repeat(auto-fill,minmax(155px,1fr))}
  .chart-peak-pos{font-size:19px;min-width:32px}
  .chart-peaks-section{padding:16px}
}
@media(max-width:600px){
  .no1-hero{padding:12px;gap:12px}
  .no1-hero-art{width:64px;height:64px}
  .no1-hero-title{font-size:15px}
  .no1-hero-artist{font-size:12px}
  .dp-month-grid{grid-template-columns:repeat(3,1fr)}
}

.chart-type-toggle{display:flex;gap:3px;margin-bottom:16px;background:rgba(255,255,255,.03);border-radius:10px;padding:3px;border:1px solid var(--border)}
.chart-type-btn{flex:1;padding:9px 16px;border-radius:8px;border:none;background:transparent;color:var(--text-dim);font-weight:600;font-size:13px;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .2s;text-align:center;white-space:nowrap}
.chart-type-btn.active{background:var(--gold);color:#111}
.chart-type-btn:hover:not(.active){background:rgba(255,255,255,.06)}
.b200-load-overlay{background:var(--bg2);border:1px solid var(--border);border-radius:14px;padding:32px 24px;text-align:center;margin:24px 0}
.b200-load-overlay h3{font-family:'Playfair Display',serif;color:var(--gold);font-size:22px;margin-bottom:8px}
.b200-load-overlay p{color:var(--text-dim);font-size:13px;margin-bottom:16px;line-height:1.5}
.b200-load-btn{padding:12px 32px;border-radius:10px;border:none;background:var(--gold);color:#111;font-weight:700;font-size:14px;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .2s}
.b200-load-btn:hover{filter:brightness(1.1);transform:translateY(-1px)}
.b200-load-btn:disabled{opacity:.5;cursor:default;transform:none}
.b200-progress{margin-top:16px;display:none}
.b200-progress.visible{display:block}
.b200-progress-bar{background:#1a1a1a;border-radius:8px;height:8px;overflow:hidden;margin-top:8px}
.b200-progress-fill{height:100%;background:linear-gradient(90deg,var(--gold),#f0d060);border-radius:8px;transition:width .3s;width:0%}
.b200-progress-text{font-size:12px;color:var(--text-faint);font-family:'DM Mono',monospace;margin-top:6px}

.footer{margin-top:48px;padding-top:24px;border-top:1px solid var(--border);text-align:center}
.footer p{font-size:11px;color:var(--text-faint);font-family:'DM Mono',monospace}
.footer .legal{font-size:10px;color:#444;margin-top:4px}

/* ‚îÄ‚îÄ‚îÄ COLLAPSIBLE DATA PANEL ‚îÄ‚îÄ‚îÄ */
.data-panel{border:1px solid var(--border);border-radius:12px;overflow:hidden;margin-bottom:20px}
.data-panel-toggle{width:100%;display:flex;align-items:center;justify-content:space-between;padding:14px 20px;background:var(--bg2);border:none;color:var(--text);font-size:13px;font-weight:600;cursor:pointer;font-family:'DM Sans',sans-serif;transition:background .15s}
.data-panel-toggle:hover{background:rgba(255,255,255,.04)}
.data-panel-toggle .toggle-left{display:flex;align-items:center;gap:8px}
.data-panel-toggle .toggle-badge{font-size:11px;color:var(--up);background:rgba(74,222,128,.1);padding:2px 8px;border-radius:10px;font-family:'DM Mono',monospace}
.data-panel-toggle .toggle-arrow{transition:transform .2s;font-size:10px;color:var(--text-faint)}
.data-panel.open .toggle-arrow{transform:rotate(180deg)}
.data-panel-body{max-height:0;overflow:hidden;transition:max-height .3s ease,padding .3s ease;padding:0 20px}
.data-panel.open .data-panel-body{max-height:400px;padding:16px 20px}

/* ‚îÄ‚îÄ‚îÄ DECADE NAV ‚îÄ‚îÄ‚îÄ */
.decade-nav{display:flex;gap:4px;margin-bottom:16px;flex-wrap:wrap;align-items:center}
.decade-nav-btn{padding:7px 14px;border-radius:8px;border:1px solid var(--border2);background:var(--bg3);color:var(--text-dim);font-size:12px;font-weight:600;cursor:pointer;font-family:'DM Sans',sans-serif;transition:all .15s;position:relative}
.decade-nav-btn:hover{border-color:var(--gold);color:var(--gold)}
.decade-nav-btn.active{background:var(--gold);color:#111;border-color:var(--gold)}
.year-drawer{display:none;gap:3px;margin-bottom:14px;flex-wrap:wrap;padding:8px 12px;background:rgba(255,255,255,.02);border:1px solid var(--border);border-radius:10px}
.year-drawer.open{display:flex}
.year-pill{padding:4px 10px;border-radius:5px;border:none;background:rgba(255,255,255,.05);color:var(--text-dim);font-size:11px;font-weight:500;cursor:pointer;font-family:'DM Mono',monospace;transition:all .12s}
.year-pill:hover{background:rgba(212,175,55,.15);color:var(--gold)}
.year-pill.active{background:var(--gold);color:#111;font-weight:700}

/* ‚îÄ‚îÄ‚îÄ SKELETON LOADING ‚îÄ‚îÄ‚îÄ */
@keyframes shimmer{0%{background-position:-400px 0}100%{background-position:400px 0}}
.skeleton{background:linear-gradient(90deg,rgba(255,255,255,.03) 25%,rgba(255,255,255,.06) 50%,rgba(255,255,255,.03) 75%);background-size:400px 100%;animation:shimmer 1.5s infinite}
.skeleton-entry{display:flex;align-items:center;gap:14px;padding:12px 16px}
.skeleton-circle{width:36px;height:36px;border-radius:50%;flex-shrink:0}
.skeleton-lines{flex:1;display:flex;flex-direction:column;gap:6px}
.skeleton-line{height:12px;border-radius:4px}
.skeleton-line.w60{width:60%}
.skeleton-line.w35{width:35%}
.skeleton-stats{display:flex;gap:12px;flex-shrink:0}
.skeleton-stat{width:28px;height:24px;border-radius:4px}

/* ‚îÄ‚îÄ‚îÄ ENHANCED #1 ENTRY ‚îÄ‚îÄ‚îÄ */
.chart-entry.no1-entry{background:linear-gradient(135deg,rgba(212,175,55,.08),rgba(212,175,55,.02));padding:16px;position:relative;overflow:hidden}
.chart-entry.no1-entry::before{content:'';position:absolute;top:-20px;right:-20px;width:100px;height:100px;background:radial-gradient(circle,rgba(212,175,55,.12),transparent 70%);pointer-events:none}
.chart-entry.no1-entry .entry-title{font-size:17px}
.chart-entry.no1-entry .entry-artist{font-size:14px}
.no1-crown{font-size:11px;color:var(--gold);font-weight:700;letter-spacing:.5px;display:flex;align-items:center;gap:4px}

/* ‚îÄ‚îÄ‚îÄ TOP 3 ENHANCED ‚îÄ‚îÄ‚îÄ */
.chart-entry.top3-entry{padding:13px 16px}
.chart-entry.top3-entry .entry-title{font-size:16px}

/* ‚îÄ‚îÄ‚îÄ MOVEMENT BADGE (replaces plain arrow) ‚îÄ‚îÄ‚îÄ */
.move-badge{font-size:11px;font-weight:700;font-family:'DM Mono',monospace;padding:2px 6px;border-radius:4px;min-width:36px;text-align:center;white-space:nowrap}
.move-badge.up{color:var(--up);background:rgba(74,222,128,.08)}
.move-badge.down{color:var(--down);background:rgba(248,113,113,.08)}
.move-badge.same{color:var(--same)}
.move-badge.new{color:var(--new);background:rgba(251,191,36,.1)}

/* ‚îÄ‚îÄ‚îÄ ARTIST SONG CARDS ‚îÄ‚îÄ‚îÄ */
.artist-hit{display:flex;align-items:center;gap:14px;padding:12px 16px;transition:all .2s;cursor:default;opacity:0;transform:translateY(6px);animation:fadeIn .3s forwards;position:relative;overflow:hidden}
.artist-hit:hover{background:rgba(255,255,255,.04)}
.artist-hit .hit-bg-bar{position:absolute;left:0;top:0;height:100%;pointer-events:none;transition:width .8s ease-out}
.artist-hit-art{width:48px;height:48px;border-radius:6px;overflow:hidden;background:rgba(255,255,255,.04);flex-shrink:0;position:relative;z-index:1;border:1px solid rgba(255,255,255,.06)}
.artist-hit-art img{width:100%;height:100%;object-fit:cover}
.artist-hit-art .art-placeholder{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:18px;color:#333}

.artist-hit-info{flex:1;min-width:0;position:relative;z-index:1}
.artist-hit-title{font-weight:700;font-size:15px;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:pointer}
.artist-hit-title:hover{text-decoration:underline;text-decoration-color:var(--gold)}
.artist-hit-sub{display:flex;align-items:center;gap:8px;margin-top:3px;flex-wrap:wrap}
.artist-hit-year{font-size:12px;color:var(--text-dim);font-family:'DM Mono',monospace}
.artist-hit-feat{font-size:11px;color:#555;font-style:italic}
.artist-hit-right{display:flex;align-items:center;gap:14px;flex-shrink:0;position:relative;z-index:1}
.artist-hit-peak{display:flex;flex-direction:column;align-items:center;gap:1px}
.artist-hit-peak-num{font-size:18px;font-weight:800;font-family:'DM Mono',monospace;line-height:1}
.artist-hit-peak-label{font-size:9px;color:var(--text-faint);text-transform:uppercase;letter-spacing:.5px}
.artist-hit-weeks{display:flex;flex-direction:column;align-items:center;gap:1px}
.artist-hit-weeks-num{font-size:14px;font-weight:600;color:var(--text-dim);font-family:'DM Mono',monospace}
.artist-hit-weeks-label{font-size:9px;color:var(--text-faint);text-transform:uppercase;letter-spacing:.5px}

/* Peak gauge bar */
.peak-gauge{width:60px;height:4px;background:rgba(255,255,255,.06);border-radius:2px;overflow:hidden;position:relative;z-index:1}
.peak-gauge-fill{height:100%;border-radius:2px;transition:width .6s ease-out}

/* Tier styling */
.artist-hit.tier-1{padding:16px;background:linear-gradient(135deg,rgba(212,175,55,.08),transparent)}
.artist-hit.tier-1 .artist-hit-art{width:56px;height:56px;border-radius:8px;border-color:rgba(212,175,55,.3);box-shadow:0 2px 12px rgba(212,175,55,.15)}
.artist-hit.tier-1 .artist-hit-title{font-size:17px}
.artist-hit.tier-1 .artist-hit-peak-num{color:var(--gold);font-size:22px}
.artist-hit.tier-1::before{content:'';position:absolute;top:-20px;right:-20px;width:80px;height:80px;background:radial-gradient(circle,rgba(212,175,55,.1),transparent 70%);pointer-events:none}

.artist-hit.tier-2{padding:14px 16px}
.artist-hit.tier-2 .artist-hit-art{width:52px;height:52px}
.artist-hit.tier-2 .artist-hit-title{font-size:16px}
.artist-hit.tier-2 .artist-hit-peak-num{color:#ccc;font-size:20px}

.artist-hit.tier-3 .artist-hit-peak-num{color:#999}

/* No1 crown inline */
.hit-crown{font-size:12px;margin-left:2px}
.hit-tier-badge{font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;padding:2px 6px;border-radius:4px;white-space:nowrap}
.hit-tier-badge.gold{color:var(--gold);background:rgba(212,175,55,.12)}
.hit-tier-badge.top10{color:#aaa;background:rgba(255,255,255,.05)}
.hit-tier-badge.top40{color:#666;background:rgba(255,255,255,.03)}

@media(max-width:600px){
  .artist-hit-art{width:40px;height:40px}
  .artist-hit.tier-1 .artist-hit-art{width:48px;height:48px}
  .artist-hit.tier-2 .artist-hit-art{width:44px;height:44px}
  .artist-hit-right{gap:10px}
  .peak-gauge{width:40px}
}
.breadcrumb{display:flex;align-items:center;gap:6px;margin-bottom:16px;font-size:12px;font-family:'DM Mono',monospace;flex-wrap:wrap}
.breadcrumb a{color:var(--text-faint);cursor:pointer;transition:color .15s}
.breadcrumb a:hover{color:var(--gold)}
.breadcrumb .sep{color:var(--text-ghost)}
.breadcrumb .current{color:var(--text-dim)}

/* ‚îÄ‚îÄ‚îÄ KEYBOARD FOCUS ‚îÄ‚îÄ‚îÄ */
.arrow-btn:focus-visible,.nav-btn:focus-visible,.jump-btn:focus-visible,.decade-nav-btn:focus-visible{outline:2px solid var(--gold);outline-offset:2px}

/* ‚îÄ‚îÄ‚îÄ FOOTER FIX ‚îÄ‚îÄ‚îÄ */
.footer p{color:var(--text-faint)}
.footer .legal{color:#444;margin-top:4px}

@media(max-width:600px){
  .logo{font-size:26px}.tagline{display:none}
  .search-input{font-size:14px}
  .entry-stats{gap:6px;overflow-x:auto;flex-shrink:1;-webkit-overflow-scrolling:touch;scrollbar-width:none}
  .entry-stats::-webkit-scrollbar{display:none}
  .stat-col{flex-shrink:0}
  .jump-btn{padding:4px 8px;font-size:10px}
  .decade-nav-btn{padding:6px 10px;font-size:11px}
  .chart-entry.no1-entry .entry-title{font-size:15px}
}
</style>
</head>
<body>

<header class="header">
  <div class="header-inner">
    <div class="logo-row">
      <h1 class="logo">ChartVault</h1>
      <span class="tagline">Billboard Chart Archive</span>
    </div>
    <div class="chart-type-toggle">
      <button class="chart-type-btn active" onclick="switchChartType('hot100')">üéµ Hot 100 Singles</button>
      <button class="chart-type-btn" onclick="switchChartType('billboard200')">üíø Billboard 200 Albums</button>
    </div>
    <nav class="nav">
      <button class="nav-btn active" data-view="weekly" onclick="switchView('weekly')">üìä Weekly Charts</button>
      <button class="nav-btn" data-view="search" onclick="switchView('search')">üîç Search</button>
      <button class="nav-btn" data-view="artist" onclick="switchView('artist')">üé§ Artist Lookup</button>
    </nav>
  </div>
</header>

<div class="main">
  <div id="loadMsg" class="load-msg"></div>
  <div id="loadBarWrap" class="load-bar-wrap"><div id="loadBar" class="load-bar"></div></div>

  <!-- ‚ïê‚ïê‚ïê WEEKLY ‚ïê‚ïê‚ïê -->
  <div id="view-weekly" class="view active">
    <div id="startupInfo" class="info-box">
      <h3>‚è≥ Connecting to chart database...</h3>
      <p>ChartVault pulls real Billboard Hot 100 data from a free public database. Just a moment...</p>
    </div>

    <div id="b200StartupInfo" class="info-box" style="display:none"></div>

    <div id="weeklyControls" style="display:none">
      <div class="data-panel" id="dataPanel">
        <button class="data-panel-toggle" onclick="toggleDataPanel()">
          <span class="toggle-left">üì• Data Management <span class="toggle-badge" id="dataBadge">0 weeks</span></span>
          <span class="toggle-arrow">‚ñº</span>
        </button>
        <div class="data-panel-body">
          <p style="font-size:12px;color:var(--text-faint);margin-bottom:12px">Load all chart weeks for a decade. Each decade takes 2‚Äì4 minutes on first load, then loads instantly from your browser.</p>
          <div class="preload-btns">
            <button class="preload-btn" id="preload60s" onclick="preloadDecade(1958,1969)">60s (1958‚Äì69)</button>
            <button class="preload-btn" id="preload70s" onclick="preloadDecade(1970,1979)">70s</button>
            <button class="preload-btn" id="preload80s" onclick="preloadDecade(1980,1989)">80s</button>
            <button class="preload-btn" id="preload90s" onclick="preloadDecade(1990,1999)">90s</button>
            <button class="preload-btn" id="preload00s" onclick="preloadDecade(2000,2009)">00s</button>
            <button class="preload-btn" id="preload10s" onclick="preloadDecade(2010,2019)">10s</button>
            <button class="preload-btn" id="preloadAll" onclick="preloadDecade(1958,2019)">Load All (1958‚Äì2019)</button>
          </div>
          <div id="preloadStatus" style="font-size:12px;color:var(--text-faint);font-family:'DM Mono',monospace;margin-top:8px"></div>
          <div id="cacheInfo" class="cache-info"></div>
        </div>
      </div>

      <div class="decade-nav" id="decadeNav">
        <button class="decade-nav-btn" onclick="selectDecade(1958,'60s')">60s</button>
        <button class="decade-nav-btn" onclick="selectDecade(1970,'70s')">70s</button>
        <button class="decade-nav-btn" onclick="selectDecade(1980,'80s')">80s</button>
        <button class="decade-nav-btn" onclick="selectDecade(1990,'90s')">90s</button>
        <button class="decade-nav-btn" onclick="selectDecade(2000,'00s')">00s</button>
        <button class="decade-nav-btn" onclick="selectDecade(2010,'10s')">10s</button>
      </div>
      <div class="year-drawer" id="yearDrawer"></div>

      <div class="selectors">
        <div class="sel-group" style="flex:2">
          <label class="sel-label">Chart Week</label>
          <select id="dateSelect" class="sel-select" onchange="loadChartWeek()" style="display:none"></select>
          <div class="date-picker-wrap" id="datePickerWrap">
            <button class="date-picker-btn" id="datePickerBtn" onclick="toggleDatePicker()"><span id="datePickerLabel">Select a week...</span><span class="dp-arrow">‚ñº</span></button>
            <div class="date-picker-panel" id="datePickerPanel">
              <div class="dp-month-grid" id="dpMonthGrid"></div>
              <div class="dp-week-list" id="dpWeekList"></div>
            </div>
          </div>
        </div>
        <div class="sel-group" style="flex:0 0 auto;display:flex;align-items:flex-end;gap:4px">
          <button class="arrow-btn" onclick="prevWeek()">‚óÄ</button>
          <button class="arrow-btn" onclick="nextWeek()">‚ñ∂</button>
          <button class="share-btn" id="shareBtnH100" onclick="shareChart()" title="Share this chart week">üîó Share</button>
        </div>
      </div>
    </div>

    <!-- Billboard 200 controls -->
    <div id="b200Controls" style="display:none">
      <div class="decade-nav" id="b200DecadeNav">
        <button class="decade-nav-btn" onclick="selectAlbumDecade(1963,'60s')">60s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(1970,'70s')">70s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(1980,'80s')">80s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(1990,'90s')">90s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(2000,'00s')">00s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(2010,'10s')">10s</button>
        <button class="decade-nav-btn" onclick="selectAlbumDecade(2020,'20s')">20s</button>
      </div>
      <div class="year-drawer" id="b200YearDrawer"></div>

      <div class="selectors">
        <div class="sel-group" style="flex:2">
          <label class="sel-label">Chart Week</label>
          <select id="albumDateSelect" class="sel-select" onchange="loadAlbumChartWeek()" style="display:none"></select>
          <div class="date-picker-wrap" id="b200DatePickerWrap">
            <button class="date-picker-btn" id="b200DatePickerBtn" onclick="toggleDatePicker('b200')"><span id="b200DatePickerLabel">Select a week...</span><span class="dp-arrow">‚ñº</span></button>
            <div class="date-picker-panel" id="b200DatePickerPanel">
              <div class="dp-month-grid" id="b200DpMonthGrid"></div>
              <div class="dp-week-list" id="b200DpWeekList"></div>
            </div>
          </div>
        </div>
        <div class="sel-group" style="flex:0 0 auto;display:flex;align-items:flex-end;gap:4px">
          <button class="arrow-btn" onclick="prevAlbumWeek()">‚óÄ</button>
          <button class="arrow-btn" onclick="nextAlbumWeek()">‚ñ∂</button>
          <button class="share-btn" id="shareBtnB200" onclick="shareChart()" title="Share this chart week">üîó Share</button>
        </div>
      </div>
      <div id="b200CacheInfo" class="cache-info"></div>
    </div>

    <div id="chartHeader"></div>
    <div id="chartList"></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê SEARCH ‚ïê‚ïê‚ïê -->
  <div id="view-search" class="view">
    <div class="search-wrap">
      <input type="text" id="searchInput" class="search-input" placeholder="Search songs or artists..." oninput="doSearch()">
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">All</button>
        <button class="filter-btn" data-filter="song" onclick="setFilter('song')"><span id="filterSongLabel">Song</span></button>
        <button class="filter-btn" data-filter="artist" onclick="setFilter('artist')">Artist</button>
      </div>
    </div>
    <div id="searchNote" class="info-box">
      <h3>How search works</h3>
      <p id="searchNoteText">Search finds songs across all loaded chart weeks. Use "Load Full Decades" on the Charts tab first for the most complete results.</p>
    </div>
    <div id="searchResults"></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê ARTIST ‚ïê‚ïê‚ïê -->
  <div id="view-artist" class="view">
    <div class="selectors">
      <div class="sel-group" style="flex:1">
        <label class="sel-label">Artist Name</label>
        <input type="text" id="artistInput" class="sel-input" placeholder="Type an artist name..." oninput="filterArtists()">
      </div>
    </div>
    <div id="artistSuggestions" style="margin-bottom:16px"></div>
    <div id="artistContent">
      <div class="info-box">
        <h3>Artist Lookup</h3>
        <p id="artistHelpText">Type an artist name to see their chart history. Load full decades from the Charts tab for the most complete results.</p>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê SONG DETAIL ‚ïê‚ïê‚ïê -->
  <div id="view-song" class="view">
    <div id="songContent"></div>
  </div>

  <footer class="footer">
    <p>CHARTVAULT &bull; Hot 100 data from <a href="https://github.com/mhollingshead/billboard-hot-100" target="_blank">mhollingshead/billboard-hot-100</a> &bull; Billboard 200 data from <a href="https://github.com/utdata/rwd-billboard-data" target="_blank">utdata/rwd-billboard-data</a></p>
    <p class="legal">Billboard¬Æ is a registered trademark of Billboard Media, LLC. Chart data for reference only.</p>
    <p class="legal" id="footerStats"></p>
  </footer>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHARTVAULT v4 ‚Äì Billboard Hot 100 & Billboard 200 Archive
// With IndexedDB caching for instant loads on return visits
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const GH = 'https://raw.githubusercontent.com/mhollingshead/billboard-hot-100/main';
const B200_CSV = 'https://raw.githubusercontent.com/utdata/rwd-billboard-data/main/data-out/billboard-200-current.csv';
const DB_NAME = 'ChartVaultDB';
const DB_VERSION = 2;
const STORE_HOT = 'charts';
const STORE_ALBUM = 'albums';

// Active chart type: 'hot100' or 'billboard200'
let chartType = 'hot100';

// Hot 100 state
let allDates = [], filteredDates = [], chartCache = {};

// Billboard 200 state
let albumDates = [], filteredAlbumDates = [], albumCache = {};
let b200Loaded = false, b200Loading = false;

let currentDate = '', showCount = 40, isPreloading = false;
let db = null;
let previousView = 'weekly';

// Helpers to get active data based on chart type
function activeCache() { return chartType === 'hot100' ? chartCache : albumCache; }
function activeDates() { return chartType === 'hot100' ? filteredDates : filteredAlbumDates; }
function chartLabel() { return chartType === 'hot100' ? 'Hot 100' : 'Billboard 200'; }
function itemLabel(plural) { return chartType === 'hot100' ? (plural ? 'songs' : 'song') : (plural ? 'albums' : 'album'); }
function chartSize() { return chartType === 'hot100' ? 100 : 200; }

// ‚îÄ‚îÄ‚îÄ INDEXEDDB (browser storage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// This saves chart data so you don't have to re-download it every visit

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(STORE_HOT)) d.createObjectStore(STORE_HOT);
      if (!d.objectStoreNames.contains(STORE_ALBUM)) d.createObjectStore(STORE_ALBUM);
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = () => resolve(null); // Fail gracefully
  });
}

function dbPut(date, entries, store) {
  if (!db) return;
  const storeName = store || STORE_HOT;
  try {
    const tx = db.transaction(storeName, 'readwrite');
    tx.objectStore(storeName).put(entries, date);
  } catch(e) { /* ignore storage errors */ }
}

function dbGet(date, store) {
  if (!db) return Promise.resolve(null);
  const storeName = store || STORE_HOT;
  return new Promise((resolve) => {
    try {
      const tx = db.transaction(storeName, 'readonly');
      const req = tx.objectStore(storeName).get(date);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => resolve(null);
    } catch(e) { resolve(null); }
  });
}

function dbGetAllKeys(store) {
  if (!db) return Promise.resolve([]);
  const storeName = store || STORE_HOT;
  return new Promise((resolve) => {
    try {
      const tx = db.transaction(storeName, 'readonly');
      const req = tx.objectStore(storeName).getAllKeys();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => resolve([]);
    } catch(e) { resolve([]); }
  });
}

function dbClear(store) {
  if (!db) return;
  const storeName = store || STORE_HOT;
  try {
    const tx = db.transaction(storeName, 'readwrite');
    tx.objectStore(storeName).clear();
  } catch(e) {}
}

// Load all saved data from IndexedDB into memory
async function loadFromDB(store, targetCache) {
  if (!db) return 0;
  const storeName = store || STORE_HOT;
  const cache = targetCache || chartCache;
  return new Promise((resolve) => {
    try {
      const tx = db.transaction(storeName, 'readonly');
      const s = tx.objectStore(storeName);
      const req = s.openCursor();
      let count = 0;
      req.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          if (Array.isArray(cursor.value) && cursor.value.length > 0) {
            cache[cursor.key] = cursor.value;
            count++;
          }
          cursor.continue();
        } else {
          resolve(count);
        }
      };
      req.onerror = () => resolve(0);
    } catch(e) { resolve(0); }
  });
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function init() {
  await openDB();

  // Load Hot 100 cached data
  const cachedCount = await loadFromDB(STORE_HOT, chartCache);

  // Load Billboard 200 cached data
  const albumCachedCount = await loadFromDB(STORE_ALBUM, albumCache);
  if (albumCachedCount > 0) {
    albumDates = Object.keys(albumCache).sort();
    filteredAlbumDates = albumDates;
    b200Loaded = true;
  }

  try {
    const r = await fetch(GH + '/valid_dates.json');
    if (!r.ok) throw new Error('HTTP ' + r.status);
    allDates = await r.json();

    filteredDates = allDates.filter(d => {
      const y = +d.substring(0, 4);
      return y >= 1958 && y <= 2019;
    });

    let msg = `‚úÖ Ready ‚Äî ${filteredDates.length} chart weeks available (1958‚Äì2019)`;
    if (cachedCount > 0) {
      msg = `‚úÖ Ready ‚Äî ${filteredDates.length} weeks available &bull; ${cachedCount} already saved in your browser`;
    }
    document.getElementById('startupInfo').innerHTML = `<h3>${msg}</h3><p>Pick any week to view the full Hot 100. Use "Load Full Decades" for searching and artist lookup across entire decades.</p>`;

    populateDateSelect();
    document.getElementById('weeklyControls').style.display = 'block';
    updateCacheInfo();

    // Check for hash route ‚Äî navigate there instead of default
    const route = parseHash();
    if (route && route.type === 'chart' && route.chart === 'hot100' && filteredDates.includes(route.date)) {
      loadChartWeek(route.date);
    } else if (route && route.type === 'chart' && route.chart === 'billboard200' && b200Loaded && filteredAlbumDates.includes(route.date)) {
      switchChartType('billboard200');
      setTimeout(() => loadAlbumChartWeek(route.date), 100);
    } else if (route && route.type === 'artist') {
      const def = filteredDates.find(d => d.startsWith('1979-08')) || filteredDates[Math.floor(filteredDates.length / 2)];
      loadChartWeek(def);
      setTimeout(() => { document.getElementById('artistInput').value = route.name; switchView('artist'); showArtist(route.name); }, 100);
    } else if (route && route.type === 'song') {
      const def = filteredDates.find(d => d.startsWith('1979-08')) || filteredDates[Math.floor(filteredDates.length / 2)];
      loadChartWeek(def);
      setTimeout(() => showSong(route.title, route.artist), 100);
    } else {
      const def = filteredDates.find(d => d.startsWith('1979-08')) || filteredDates[Math.floor(filteredDates.length / 2)];
      loadChartWeek(def);
    }

  } catch(e) {
    if (cachedCount > 0) {
      filteredDates = Object.keys(chartCache).sort();
      document.getElementById('startupInfo').innerHTML = `<h3 style="color:var(--new)">üì¥ Offline Mode ‚Äî ${cachedCount} saved weeks available</h3><p>Could not reach GitHub, but your previously loaded data is available.</p>`;
      populateDateSelect();
      document.getElementById('weeklyControls').style.display = 'block';
      if (filteredDates.length) {
        loadChartWeek(filteredDates[Math.floor(filteredDates.length / 2)]);
      }
    } else {
      document.getElementById('startupInfo').innerHTML = `<h3 style="color:var(--down)">‚ö†Ô∏è Connection Error</h3><p>Could not reach the chart database. Make sure you're connected to the internet and refresh.</p><p style="margin-top:8px;font-size:12px;color:#555">${e.message}</p>`;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ CHART TYPE SWITCHING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function switchChartType(type) {
  if (type === chartType) return;
  chartType = type;
  document.querySelectorAll('.chart-type-btn').forEach(b => {
    b.classList.toggle('active', b.textContent.includes(type === 'billboard200' ? '200' : '100'));
  });

  if (type === 'billboard200') {
    showBillboard200View();
  } else {
    showHot100View();
  }
}

function showHot100View() {
  document.getElementById('b200Controls').style.display = 'none';
  document.getElementById('weeklyControls').style.display = 'block';
  document.getElementById('startupInfo').style.display = 'block';
  document.getElementById('b200StartupInfo').style.display = 'none';
  // Update search/artist labels
  document.getElementById('searchInput').placeholder = 'Search songs or artists...';
  document.getElementById('filterSongLabel').textContent = 'Song';
  document.getElementById('searchNoteText').textContent = 'Search finds songs across all loaded chart weeks. Use "Load Full Decades" on the Charts tab first for the most complete results.';
  document.getElementById('artistHelpText').textContent = 'Type an artist name to see their chart history. Load full decades from the Charts tab for the most complete results.';
  switchView('weekly');
  if (currentDate && chartCache[currentDate]) {
    displayChart(currentDate, chartCache[currentDate]);
  }
  updateStats();
}

function showBillboard200View() {
  document.getElementById('weeklyControls').style.display = 'none';
  document.getElementById('startupInfo').style.display = 'none';
  document.getElementById('b200StartupInfo').style.display = 'block';
  // Update search/artist labels
  document.getElementById('searchInput').placeholder = 'Search albums or artists...';
  document.getElementById('filterSongLabel').textContent = 'Album';
  document.getElementById('searchNoteText').textContent = 'Search finds albums across all Billboard 200 chart weeks. Download Billboard 200 data from the Charts tab first.';
  document.getElementById('artistHelpText').textContent = 'Type an artist name to see their Billboard 200 album chart history.';
  switchView('weekly');

  if (b200Loaded && filteredAlbumDates.length > 0) {
    document.getElementById('b200Controls').style.display = 'block';
    document.getElementById('b200StartupInfo').innerHTML = `<h3>‚úÖ Billboard 200 ‚Äî ${filteredAlbumDates.length} chart weeks loaded</h3><p>Browse album charts, search albums, or look up artists.</p>`;
    populateAlbumDateSelect();
    updateAlbumCacheInfo();
    if (!currentDate || !albumCache[currentDate]) {
      const def = filteredAlbumDates.find(d => d.startsWith('1979')) || filteredAlbumDates[Math.floor(filteredAlbumDates.length / 2)];
      loadAlbumChartWeek(def);
    }
  } else {
    document.getElementById('b200Controls').style.display = 'none';
    document.getElementById('b200StartupInfo').innerHTML = `
      <div class="b200-load-overlay">
        <h3>üíø Billboard 200 Album Charts</h3>
        <p>Load the complete Billboard 200 album chart history (1963‚Äìpresent).<br>
        This downloads ~35MB of data once, then saves to your browser for instant access on future visits.</p>
        <button class="b200-load-btn" id="b200LoadBtn" onclick="loadBillboard200()">Download Billboard 200 Data</button>
        <div class="b200-progress" id="b200Progress">
          <div class="b200-progress-bar"><div class="b200-progress-fill" id="b200ProgressFill"></div></div>
          <div class="b200-progress-text" id="b200ProgressText"></div>
        </div>
      </div>`;
  }
}

// ‚îÄ‚îÄ‚îÄ BILLBOARD 200 CSV LOADING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function loadBillboard200() {
  if (b200Loading) return;
  b200Loading = true;
  const btn = document.getElementById('b200LoadBtn');
  const prog = document.getElementById('b200Progress');
  const fill = document.getElementById('b200ProgressFill');
  const txt = document.getElementById('b200ProgressText');
  btn.disabled = true;
  btn.textContent = 'Downloading...';
  prog.classList.add('visible');
  txt.textContent = 'Downloading Billboard 200 data...';
  fill.style.width = '5%';

  try {
    if (typeof Papa === 'undefined') throw new Error('CSV parser not loaded. Please refresh and try again.');

    // Fetch the CSV text
    const response = await fetch(B200_CSV);
    if (!response.ok) throw new Error('HTTP ' + response.status);
    fill.style.width = '30%';
    txt.textContent = 'Reading response...';

    const csvText = await response.text();
    fill.style.width = '45%';
    txt.textContent = 'Parsing ' + (csvText.length / 1048576).toFixed(1) + ' MB of chart data...';

    // Parse with step mode to avoid double-memory from holding parsed array
    const tempCache = {};
    let rowCount = 0;
    let headerParsed = false;
    let dateIdx, rankIdx, titleIdx, artistIdx, lwIdx, peakIdx, wksIdx;

    Papa.parse(csvText, {
      header: false,
      skipEmptyLines: true,
      step: function(result) {
        const row = result.data;
        if (!row || row.length < 4) return;

        if (!headerParsed) {
          const h = row.map(function(c) { return (c || '').trim().toLowerCase(); });
          // Try known column names
          dateIdx = h.indexOf('chart_date');
          if (dateIdx < 0) dateIdx = h.indexOf('chart week');
          if (dateIdx < 0) dateIdx = h.indexOf('chart_week');
          rankIdx = h.indexOf('current_rank');
          if (rankIdx < 0) rankIdx = h.indexOf('this week');
          if (rankIdx < 0) rankIdx = h.indexOf('this_week');
          titleIdx = h.indexOf('title');
          if (titleIdx < 0) titleIdx = h.indexOf('song');
          artistIdx = h.indexOf('performer');
          if (artistIdx < 0) artistIdx = h.indexOf('artist');
          lwIdx = h.indexOf('previous_rank');
          if (lwIdx < 0) lwIdx = h.indexOf('last week');
          if (lwIdx < 0) lwIdx = h.indexOf('last_week');
          if (lwIdx < 0) lwIdx = h.indexOf('previous_week');
          peakIdx = h.indexOf('peak_rank');
          if (peakIdx < 0) peakIdx = h.indexOf('peak pos.');
          if (peakIdx < 0) peakIdx = h.indexOf('peak_pos');
          if (peakIdx < 0) peakIdx = h.indexOf('peak_position');
          wksIdx = h.indexOf('wks_on_chart');
          if (wksIdx < 0) wksIdx = h.indexOf('wks on chart');
          if (wksIdx < 0) wksIdx = h.indexOf('weeks_on_chart');
          if (wksIdx < 0) wksIdx = h.indexOf('time_on_chart');

          // If we matched at least date+rank+title, it's a header row
          if (dateIdx >= 0 && rankIdx >= 0 && titleIdx >= 0) {
            headerParsed = true;
            return;
          }
          // Otherwise assume positional and process this row as data
          dateIdx = 0; rankIdx = 1; titleIdx = 2; artistIdx = 3; lwIdx = 4; peakIdx = 5; wksIdx = 6;
          headerParsed = true;
          // Fall through to process this row as data
        }

        var rawDate = (row[dateIdx] || '').trim();
        if (!rawDate) return;

        // Normalize date
        var date;
        if (/^\d{4}-\d{2}-\d{2}$/.test(rawDate)) {
          date = rawDate;
        } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(rawDate)) {
          var parts = rawDate.split('/');
          date = parts[2] + '-' + parts[0].padStart(2,'0') + '-' + parts[1].padStart(2,'0');
        } else {
          try { var d = new Date(rawDate); if (!isNaN(d.getTime())) date = d.toISOString().substring(0,10); else return; } catch(ex) { return; }
        }

        var rank = parseInt(row[rankIdx]) || 0;
        var title = (row[titleIdx] || '').trim();
        var artist = artistIdx >= 0 ? (row[artistIdx] || '').trim() : '';
        if (!title || !rank) return;

        var lw = lwIdx >= 0 ? (parseInt(row[lwIdx]) || null) : null;
        var peak = peakIdx >= 0 ? (parseInt(row[peakIdx]) || rank) : rank;
        var wks = wksIdx >= 0 ? (parseInt(row[wksIdx]) || 1) : 1;

        if (!tempCache[date]) tempCache[date] = [];
        tempCache[date].push({ rank: rank, title: title, artist: artist, lastWeek: lw, peak: peak, weeks: wks });
        rowCount++;
      }
    });

    if (rowCount === 0) throw new Error('CSV parsed but no valid rows found. Headers detected: dateIdx=' + dateIdx + ' rankIdx=' + rankIdx + ' titleIdx=' + titleIdx);

    fill.style.width = '80%';
    txt.textContent = 'Sorting ' + rowCount.toLocaleString() + ' entries...';
    await new Promise(function(r) { setTimeout(r, 0); });

    // Sort each week by rank
    var dates = Object.keys(tempCache);
    for (var i = 0; i < dates.length; i++) {
      tempCache[dates[i]].sort(function(a, b) { return a.rank - b.rank; });
    }

    fill.style.width = '88%';
    txt.textContent = 'Saving to browser...';
    await new Promise(function(r) { setTimeout(r, 0); });

    albumCache = tempCache;
    albumDates = dates.sort();
    filteredAlbumDates = albumDates;

    // Save to IndexedDB in batches
    for (var j = 0; j < albumDates.length; j++) {
      dbPut(albumDates[j], albumCache[albumDates[j]], STORE_ALBUM);
      if (j % 100 === 0) {
        fill.style.width = (88 + Math.round((j / albumDates.length) * 12)) + '%';
        await new Promise(function(r) { setTimeout(r, 0); });
      }
    }

    b200Loaded = true;
    b200Loading = false;
    fill.style.width = '100%';
    txt.textContent = rowCount.toLocaleString() + ' entries across ' + albumDates.length + ' weeks loaded!';
    showBillboard200View();

  } catch(e) {
    b200Loading = false;
    btn.disabled = false;
    btn.textContent = 'Retry Download';
    txt.textContent = '‚ùå Error: ' + e.message + '. Please try again.';
    fill.style.width = '0%';
    console.error('BB200 load error:', e);
  }
}

function populateAlbumDateSelect() {
  const s = document.getElementById('albumDateSelect');
  if (!s) return;
  s.innerHTML = [...filteredAlbumDates].reverse().map(d => `<option value="${d}">${fmtDate(d)}</option>`).join('');
}

function updateAlbumCacheInfo() {
  const el = document.getElementById('b200CacheInfo');
  if (!el) return;
  const n = filteredAlbumDates.length;
  const totalEntries = Object.values(albumCache).reduce((s, e) => s + (Array.isArray(e) ? e.length : 0), 0);
  if (n > 0) {
    const range = filteredAlbumDates[0].substring(0,4) + '‚Äì' + filteredAlbumDates[n-1].substring(0,4);
    el.innerHTML = `üíæ ${n} weeks saved (${range}) &bull; ${totalEntries.toLocaleString()} entries <button class="clear-btn" onclick="clearAlbumCache()">Clear album data</button>`;
  }
}

function clearAlbumCache() {
  if (!confirm('This will delete all saved Billboard 200 data from your browser. You will need to re-download it. Continue?')) return;
  dbClear(STORE_ALBUM);
  albumCache = {};
  albumDates = [];
  filteredAlbumDates = [];
  b200Loaded = false;
  showBillboard200View();
}

function jumpToAlbumYear(y) {
  const d = filteredAlbumDates.find(d => d.startsWith(String(y)));
  if (d) {
    dpSelectedYear = y;
    dpSelectedMonth = null;
    const grid = document.getElementById('b200DpMonthGrid');
    if (grid) { dpMode = 'b200'; populateMonthGrid(); }
    document.getElementById('b200DpWeekList').innerHTML = '';
    loadAlbumChartWeek(d);
  }
}

function prevAlbumWeek() {
  const i = filteredAlbumDates.indexOf(currentDate);
  if (i > 0) loadAlbumChartWeek(filteredAlbumDates[i-1]);
}

function nextAlbumWeek() {
  const i = filteredAlbumDates.indexOf(currentDate);
  if (i < filteredAlbumDates.length-1) loadAlbumChartWeek(filteredAlbumDates[i+1]);
}

async function loadAlbumChartWeek(directDate) {
  const date = directDate || document.getElementById('albumDateSelect').value;
  if (!date) return;
  currentDate = date;
  // Sync the hidden select if the option exists
  const sel = document.getElementById('albumDateSelect');
  if (sel) sel.value = date;
  showCount = 40;
  updatePickerLabel();
  updateHash();

  // Ensure controls are visible
  if (chartType === 'billboard200' && b200Loaded) {
    document.getElementById('b200Controls').style.display = 'block';
  }

  if (albumCache[date] && albumCache[date].length > 0) {
    displayChart(date, albumCache[date]);
    return;
  }

  document.getElementById('chartHeader').innerHTML = `<h2 class="chart-title">Billboard 200</h2><div class="chart-date">Week of ${fmtDate(date)}</div>`;
  document.getElementById('chartList').innerHTML = renderSkeleton();
}

// ‚îÄ‚îÄ‚îÄ DATE NAV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function populateDateSelect() {
  const s = document.getElementById('dateSelect');
  s.innerHTML = [...filteredDates].reverse().map(d => `<option value="${d}">${fmtDate(d)}</option>`).join('');
}

// ‚îÄ‚îÄ‚îÄ DATE PICKER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let dpSelectedYear = null, dpSelectedMonth = null;
let dpOpen = false, dpMode = 'hot100'; // 'hot100' or 'b200'

function toggleDatePicker(mode) {
  const isB200 = mode === 'b200';
  const panel = document.getElementById(isB200 ? 'b200DatePickerPanel' : 'datePickerPanel');
  const btn = document.getElementById(isB200 ? 'b200DatePickerBtn' : 'datePickerBtn');
  const wasOpen = panel.classList.contains('open');

  // Close any other open picker
  document.querySelectorAll('.date-picker-panel').forEach(p => p.classList.remove('open'));
  document.querySelectorAll('.date-picker-btn').forEach(b => b.classList.remove('open'));

  if (wasOpen) { dpOpen = false; return; }

  dpMode = isB200 ? 'b200' : 'hot100';
  panel.classList.add('open');
  btn.classList.add('open');
  dpOpen = true;

  // Initialize with current date's year/month
  const curDate = currentDate || '';
  dpSelectedYear = curDate ? parseInt(curDate.substring(0, 4)) : null;
  dpSelectedMonth = curDate ? parseInt(curDate.substring(5, 7)) - 1 : null;

  populateMonthGrid();
  if (dpSelectedMonth !== null) populateWeekList();
}

function populateMonthGrid() {
  const isB200 = dpMode === 'b200';
  const grid = document.getElementById(isB200 ? 'b200DpMonthGrid' : 'dpMonthGrid');
  const dates = isB200 ? filteredAlbumDates : filteredDates;
  if (!dpSelectedYear || !dates.length) { grid.innerHTML = ''; return; }

  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  // Find which months have data for this year
  const prefix = String(dpSelectedYear);
  const availMonths = new Set();
  for (const d of dates) {
    if (d.startsWith(prefix)) availMonths.add(parseInt(d.substring(5, 7)) - 1);
  }

  grid.innerHTML = months.map((m, i) => {
    const avail = availMonths.has(i);
    const active = dpSelectedMonth === i;
    return `<button class="dp-month-btn${active ? ' active' : ''}${!avail ? ' disabled' : ''}" onclick="selectPickerMonth(${i})">${m}</button>`;
  }).join('');
}

function selectPickerMonth(m) {
  dpSelectedMonth = m;
  populateMonthGrid();
  populateWeekList();
}

function populateWeekList() {
  const isB200 = dpMode === 'b200';
  const list = document.getElementById(isB200 ? 'b200DpWeekList' : 'dpWeekList');
  const dates = isB200 ? filteredAlbumDates : filteredDates;
  if (dpSelectedYear === null || dpSelectedMonth === null) { list.innerHTML = ''; return; }

  const prefix = String(dpSelectedYear) + '-' + String(dpSelectedMonth + 1).padStart(2, '0');
  const weekDates = dates.filter(d => d.startsWith(prefix));

  if (weekDates.length === 0) {
    list.innerHTML = '<div style="font-size:12px;color:#555;padding:8px">No chart weeks this month</div>';
    return;
  }

  list.innerHTML = weekDates.map((d, i) => {
    const active = d === currentDate;
    const wi = dates.indexOf(d) + 1;
    return `<button class="dp-week-btn${active ? ' active' : ''}" onclick="selectPickerWeek('${d}')">${fmtDate(d)}<span class="dp-wk-num">Wk ${wi}</span></button>`;
  }).join('');
}

function selectPickerWeek(date) {
  // Close picker
  document.querySelectorAll('.date-picker-panel').forEach(p => p.classList.remove('open'));
  document.querySelectorAll('.date-picker-btn').forEach(b => b.classList.remove('open'));
  dpOpen = false;

  if (dpMode === 'b200') {
    loadAlbumChartWeek(date);
  } else {
    loadChartWeek(date);
  }
}

function updatePickerLabel() {
  const isB200 = chartType === 'billboard200';
  const label = document.getElementById(isB200 ? 'b200DatePickerLabel' : 'datePickerLabel');
  if (label) label.textContent = currentDate ? fmtDate(currentDate) : 'Select a week...';
}

// Close picker when clicking outside
document.addEventListener('click', e => {
  if (!dpOpen) return;
  if (!e.target.closest('.date-picker-wrap')) {
    document.querySelectorAll('.date-picker-panel').forEach(p => p.classList.remove('open'));
    document.querySelectorAll('.date-picker-btn').forEach(b => b.classList.remove('open'));
    dpOpen = false;
  }
});

function jumpToYear(y) {
  const d = filteredDates.find(d => d.startsWith(String(y)));
  if (d) {
    dpSelectedYear = y;
    dpSelectedMonth = null;
    dpMode = 'hot100';
    populateMonthGrid();
    document.getElementById('dpWeekList').innerHTML = '';
    loadChartWeek(d);
  }
}

function prevWeek() {
  const i = filteredDates.indexOf(currentDate);
  if (i > 0) loadChartWeek(filteredDates[i-1]);
}

function nextWeek() {
  const i = filteredDates.indexOf(currentDate);
  if (i < filteredDates.length-1) loadChartWeek(filteredDates[i+1]);
}

// ‚îÄ‚îÄ‚îÄ FETCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function fetchWeek(date, retries) {
  if (retries === undefined) retries = 2;
  // Memory cache
  if (chartCache[date] && chartCache[date].length > 0) return chartCache[date];
  // Try IndexedDB
  const saved = await dbGet(date, STORE_HOT);
  if (saved && Array.isArray(saved) && saved.length > 0) {
    chartCache[date] = saved;
    return saved;
  }
  // Fetch from GitHub
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const r = await fetch(`${GH}/date/${date}.json`);
      if (!r.ok) { if (attempt < retries) { await sleep(600); continue; } throw new Error('HTTP ' + r.status); }
      const raw = await r.json();
      if (!raw || !raw.data || !Array.isArray(raw.data) || raw.data.length === 0) {
        if (attempt < retries) { await sleep(600); continue; }
        throw new Error('Empty data');
      }
      const entries = raw.data.map(e => ({
        rank: e.this_week,
        title: (e.song || '').trim(),
        artist: (e.artist || '').trim(),
        lastWeek: e.last_week,
        peak: e.peak_position,
        weeks: e.weeks_on_chart
      }));
      chartCache[date] = entries;
      dbPut(date, entries, STORE_HOT); // Save to browser
      return entries;
    } catch(e) {
      if (attempt >= retries) throw e;
      await sleep(600);
    }
  }
}

async function loadChartWeek(directDate) {
  const date = directDate || document.getElementById('dateSelect').value;
  if (!date) return;
  currentDate = date;
  const sel = document.getElementById('dateSelect');
  if (sel) sel.value = date;
  showCount = 40;
  updatePickerLabel();
  updateHash();

  if (chartCache[date] && chartCache[date].length > 0) {
    displayChart(date, chartCache[date]);
    return;
  }

  document.getElementById('chartHeader').innerHTML = `<h2 class="chart-title">Hot 100</h2><div class="chart-date">Week of ${fmtDate(date)}</div>`;
  document.getElementById('chartList').innerHTML = renderSkeleton();

  try {
    const entries = await fetchWeek(date);
    displayChart(date, entries);
    updateStats();
  } catch(e) {
    document.getElementById('chartList').innerHTML = `<div class="empty"><div class="empty-icon">‚ùå</div><p>Could not load ${fmtDate(date)}</p><p class="sub">${e.message}</p></div>`;
  }
}

function displayChart(date, entries) {
  const dates = activeDates();
  const wi = dates.indexOf(date);
  const wn = wi >= 0 ? wi + 1 : '?';
  const label = chartLabel();
  document.getElementById('chartHeader').innerHTML = `
    <h2 class="chart-title">${label}</h2>
    <div class="chart-date">Week of ${fmtDate(date)}</div>
    <div class="chart-count">${entries.length} positions &bull; Week ${wn} of ${dates.length}</div>
    <div class="chart-legend"><span style="color:var(--up)">‚ñ≤ Rising</span> <span style="color:var(--down)">‚ñº Falling</span> <span style="color:var(--same)">‚Äî Steady</span> <span style="color:var(--new)">NEW Entry</span> <span style="color:var(--text-ghost);margin-left:auto">‚Üê ‚Üí arrow keys to navigate weeks</span></div>`;

  // #1 hero
  const no1 = entries.find(e => e.rank === 1);
  let heroHtml = '';
  if (no1) {
    const wkInfo = no1.weeks ? `Week ${no1.weeks} at #1` : '';
    const lw = no1.lastWeek;
    const status = !lw ? 'NEW at #1!' : lw === 1 ? 'Holding at #1' : `Up from #${lw}`;
    heroHtml = `<div class="no1-hero">
      <div class="no1-hero-art" id="no1HeroArt"><div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:28px;color:rgba(212,175,55,.3)">üëë</div></div>
      <div class="no1-hero-info">
        <div class="no1-hero-label">üëë #1 This Week</div>
        <div class="no1-hero-title" onclick="searchFor('${esc(no1.title)}','${esc(no1.artist)}')">${no1.title}</div>
        <div class="no1-hero-artist" onclick="goToArtist('${esc(no1.artist)}')">${no1.artist}</div>
        <div class="no1-hero-stat">${status}${wkInfo ? ' &bull; ' + wkInfo : ''}</div>
      </div>
    </div>`;
  }

  const vis = entries.slice(0, showCount);
  let h = heroHtml + '<div class="chart-list">';
  vis.forEach((e, i) => { h += renderEntry(e, i); if (i < vis.length - 1) h += '<div class="chart-divider"></div>'; });
  h += '</div>';
  if (showCount < entries.length) h += `<div class="show-more-wrap"><button class="show-more-btn" onclick="showMore()">Show All ${entries.length} Positions</button></div>`;
  document.getElementById('chartList').innerHTML = h;

  // Fetch #1 artwork async
  if (no1) fetchNo1HeroArt(no1.title, no1.artist);
}

async function fetchNo1HeroArt(title, artist) {
  const el = document.getElementById('no1HeroArt');
  if (!el) return;

  const hitKey = title + '|||' + artist;
  if (hitArtData[hitKey]) {
    el.innerHTML = `<img src="${hitArtData[hitKey].thumb || hitArtData[hitKey].full}" alt="">`;
    return;
  }

  const isAlbum = chartType === 'billboard200';

  try {
    const q = encodeURIComponent(title + ' ' + artist);
    const entity = isAlbum ? 'entity=album' : 'entity=song';
    const r = await fetch('https://itunes.apple.com/search?term=' + q + '&' + entity + '&country=US&limit=15');
    const d = await r.json();
    if (d.results && d.results.length) {
      const chartYear = currentDate ? parseInt(currentDate.substring(0, 4)) : null;
      const pick = pickOriginalAlbumArt(d.results, title, isAlbum, COMPILATION_RE, NORM_FN, chartYear);
      if (pick && pick.artworkUrl100) {
        el.innerHTML = `<img src="${pick.artworkUrl100}" alt="">`;
      }
    }
  } catch(e) {}
}

function showMore() { showCount = chartSize(); displayChart(currentDate, activeCache()[currentDate]); }

// ‚îÄ‚îÄ‚îÄ PRELOAD DECADES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function preloadDecade(startYr, endYr) {
  if (isPreloading) return;
  isPreloading = true;
  const dates = filteredDates.filter(d => { const y = +d.substring(0,4); return y >= startYr && y <= endYr; });
  const toLoad = dates.filter(d => !chartCache[d] || chartCache[d].length === 0);

  if (toLoad.length === 0) {
    document.getElementById('preloadStatus').textContent = `‚úÖ All ${dates.length} weeks from ${startYr}‚Äì${endYr} already loaded!`;
    isPreloading = false;
    return;
  }

  document.querySelectorAll('.preload-btn').forEach(b => b.disabled = true);
  const status = document.getElementById('preloadStatus');
  const barWrap = document.getElementById('loadBarWrap');
  const bar = document.getElementById('loadBar');
  barWrap.classList.add('visible');

  let done = 0, success = 0, errors = 0;

  // 2 concurrent requests with delay between batches
  for (let i = 0; i < toLoad.length; i += 2) {
    const batch = toLoad.slice(i, i + 2);
    const results = await Promise.allSettled(batch.map(d => fetchWeek(d)));
    results.forEach(r => {
      if (r.status === 'fulfilled' && r.value && r.value.length > 0) success++;
      else errors++;
    });
    done += batch.length;
    const pct = Math.round(done / toLoad.length * 100);
    bar.style.width = pct + '%';
    status.textContent = `Loading ${startYr}‚Äì${endYr}: ${done}/${toLoad.length} (${success} ok${errors ? ', ' + errors + ' retry needed' : ''}) ${pct}%`;
    if (i + 2 < toLoad.length) await sleep(200);
  }

  barWrap.classList.remove('visible');
  const tw = validWeekCount();
  status.textContent = `‚úÖ Done! ${success} weeks loaded. Total: ${tw} weeks in memory.`;
  document.querySelectorAll('.preload-btn').forEach(b => b.disabled = false);
  isPreloading = false;
  updateStats();
  updateCacheInfo();
}

function clearCache() {
  const label = chartType === 'hot100' ? 'Hot 100' : 'Billboard 200';
  if (!confirm(`This will delete all saved ${label} data from your browser. You will need to re-download it. Continue?`)) return;
  if (chartType === 'hot100') {
    dbClear(STORE_HOT);
    chartCache = {};
  } else {
    dbClear(STORE_ALBUM);
    albumCache = {};
    albumDates = [];
    filteredAlbumDates = [];
    b200Loaded = false;
  }
  updateCacheInfo();
  updateStats();
  document.getElementById('preloadStatus').textContent = 'Cache cleared.';
}

function updateCacheInfo() {
  const n = validWeekCount();
  const el = document.getElementById('cacheInfo');
  if (n > 0) {
    el.innerHTML = `üíæ ${n} weeks saved in browser (loads instantly on future visits) <button class="clear-btn" onclick="clearCache()">Clear saved data</button>`;
  } else {
    el.innerHTML = 'üíæ No data saved yet. Load decades above ‚Äî they\'ll be saved for future visits.';
  }
  updateDataBadge();
}

// ‚îÄ‚îÄ‚îÄ SEARCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let searchFilter = 'all';

function setFilter(f) {
  searchFilter = f;
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.toggle('active', b.dataset.filter === f));
  doSearch();
}

function doSearch() {
  const q = document.getElementById('searchInput').value.toLowerCase().trim();
  const c = document.getElementById('searchResults');
  if (q.length < 2) { c.innerHTML = ''; return; }

  const cache = activeCache();
  const results = [], seen = new Map();
  for (const [date, entries] of Object.entries(cache)) {
    if (!Array.isArray(entries)) continue;
    try {
      for (const e of entries) {
        if (!e || !e.title || !e.artist) continue;
        const tm = e.title.toLowerCase().includes(q);
        const am = e.artist.toLowerCase().includes(q);
        const m = searchFilter === 'song' ? tm : searchFilter === 'artist' ? am : (tm || am);
        if (m) {
          const k = e.title + '|' + e.artist;
          if (!seen.has(k)) {
            const item = { ...e, date };
            seen.set(k, item);
            results.push(item);
          } else {
            const existing = seen.get(k);
            if (e.peak && (!existing.peak || e.peak < existing.peak)) existing.peak = e.peak;
            if (e.weeks && (!existing.weeks || e.weeks > existing.weeks)) existing.weeks = e.weeks;
          }
        }
      }
    } catch(err) {}
  }

  results.sort((a, b) => (a.peak || 999) - (b.peak || 999));
  const cw = validWeekCount();
  const il = itemLabel(results.length !== 1);
  let h = `<div class="result-count">${results.length} unique ${il} across ${cw} loaded weeks</div>`;
  if (!results.length) {
    h += `<div class="empty"><div class="empty-icon">üîá</div><p>No results for "${q}"</p><p class="sub">${chartType === 'hot100' ? 'Load more decades from the Charts tab for more results' : 'Make sure Billboard 200 data is loaded'}</p></div>`;
  } else {
    h += '<div class="chart-list">';
    results.slice(0, 100).forEach((e, i) => {
      h += renderEntry(e, i, true);
      if (i < Math.min(results.length, 100) - 1) h += '<div class="chart-divider"></div>';
    });
    h += '</div>';
    if (results.length > 100) h += `<div style="text-align:center;padding:12px;font-size:12px;color:var(--text-faint)">Showing top 100 of ${results.length} results</div>`;
  }
  c.innerHTML = h;
}

// ‚îÄ‚îÄ‚îÄ ARTIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Match artist name including featured/collaborative credits
// "Paul Davis Feat. Susan Collins" matches both "Paul Davis" and "Susan Collins"
function artistMatches(creditedName, searchName) {
  if (creditedName === searchName) return true;
  const cLow = creditedName.toLowerCase(), sLow = searchName.toLowerCase();
  if (cLow === sLow) return true;
  // Split credited name on common delimiters
  const parts = creditedName.split(/\s+(?:feat\.?|featuring|with|&|and|vs\.?|x|\+|\/)\s+/i);
  if (parts.length <= 1) return false;
  return parts.some(p => p.trim().toLowerCase() === sLow);
}

function filterArtists() {
  const q = document.getElementById('artistInput').value.toLowerCase().trim();
  const sb = document.getElementById('artistSuggestions');
  if (q.length < 2) { sb.innerHTML = ''; return; }

  const cache = activeCache();
  const artists = new Map();
  for (const entries of Object.values(cache)) {
    if (!Array.isArray(entries)) continue;
    try {
      for (const e of entries) {
        if (!e || !e.artist) continue;
        if (e.artist.toLowerCase().includes(q)) {
          // Add the exact credited name
          if (!artists.has(e.artist)) artists.set(e.artist, { name: e.artist, count: 0, titles: new Set() });
          const a = artists.get(e.artist);
          if (!a.titles.has(e.title)) { a.titles.add(e.title); a.count++; }
          // Also add individual parts as suggestions
          const parts = e.artist.split(/\s+(?:feat\.?|featuring|with|&|and|vs\.?|x|\+|\/)\s+/i);
          if (parts.length > 1) {
            for (const p of parts) {
              const pt = p.trim();
              if (pt.toLowerCase().includes(q) && !artists.has(pt)) {
                artists.set(pt, { name: pt, count: 0, titles: new Set() });
              }
              if (pt.toLowerCase().includes(q)) {
                const ap = artists.get(pt);
                if (ap && !ap.titles.has(e.title)) { ap.titles.add(e.title); ap.count++; }
              }
            }
          }
        }
      }
    } catch(err) {}
  }

  // Also scan for partial artist name matches against individual parts
  for (const entries of Object.values(cache)) {
    if (!Array.isArray(entries)) continue;
    try {
      for (const e of entries) {
        if (!e || !e.artist) continue;
        const parts = e.artist.split(/\s+(?:feat\.?|featuring|with|&|and|vs\.?|x|\+|\/)\s+/i);
        if (parts.length <= 1) continue;
        for (const p of parts) {
          const pt = p.trim();
          if (pt.toLowerCase().includes(q)) {
            if (!artists.has(pt)) artists.set(pt, { name: pt, count: 0, titles: new Set() });
            const ap = artists.get(pt);
            if (!ap.titles.has(e.title)) { ap.titles.add(e.title); ap.count++; }
          }
        }
      }
    } catch(err) {}
  }

  const sorted = [...artists.values()].sort((a, b) => b.count - a.count).slice(0, 12);
  sb.innerHTML = sorted.map(a =>
    `<button onclick="showArtist('${esc(a.name)}')" style="padding:6px 14px;border-radius:6px;border:1px solid var(--border2);background:var(--bg3);color:var(--gold);font-size:13px;cursor:pointer;font-family:'DM Sans',sans-serif;margin:0 4px 4px 0">${a.name} <span style="color:#666">(${a.count})</span></button>`
  ).join('');

  if (sorted.length === 1 || (sorted.length > 0 && sorted[0].name.toLowerCase() === q)) showArtist(sorted[0].name);
}

function showArtist(name) {
  document.getElementById('artistInput').value = name;
  document.getElementById('artistSuggestions').innerHTML = '';

  const cache = activeCache();
  const isAlbum = chartType === 'billboard200';
  const hits = new Map();
  for (const [date, entries] of Object.entries(cache)) {
    if (!Array.isArray(entries)) continue;
    try {
      for (const e of entries) {
        if (!e || !e.artist) continue;
        if (!artistMatches(e.artist, name)) continue;
        const key = e.title + '|||' + e.artist; // unique by title+credited artist
        if (!hits.has(key)) {
          hits.set(key, { title: e.title, creditedAs: e.artist, peak: e.peak || e.rank, weeks: e.weeks || 1, firstDate: date });
        } else {
          const h = hits.get(key);
          if ((e.peak || e.rank) < h.peak) h.peak = e.peak || e.rank;
          if ((e.weeks || 0) > h.weeks) h.weeks = e.weeks;
          if (date < h.firstDate) h.firstDate = date;
        }
      }
    } catch(err) {}
  }

  const hl = [...hits.values()].sort((a, b) => (a.firstDate || '').localeCompare(b.firstDate || ''));
  const n1 = hl.filter(h => h.peak === 1).length;
  const t10 = hl.filter(h => h.peak <= 10).length;
  const t40 = hl.filter(h => h.peak <= 40).length;
  const bp = hl.length ? Math.min(...hl.map(h => h.peak)) : 0;
  const totalWks = hl.reduce((s, h) => s + (h.weeks || 0), 0);
  const c = document.getElementById('artistContent');

  if (!hl.length) {
    c.innerHTML = `<div class="artist-header"><div class="artist-hero"><div class="artist-photo-wrap" id="artistPhoto"></div><div class="artist-info-side"><h2 class="artist-name">${name}</h2><div class="artist-years">No ${chartType === 'hot100' ? 'Hot 100' : 'Billboard 200'} entries found as a performing artist</div></div></div></div><div id="songwriterCredits"></div>`;
    fetchArtistImage(name, 'artistPhoto');
    fetchSongwriterCredits(name, 'songwriterCredits');
    return;
  }

  // Year range
  const years = hl.map(h => h.firstDate ? +h.firstDate.substring(0,4) : 0).filter(y => y > 0);
  const minY = Math.min(...years), maxY = Math.max(...years);
  const yearSpan = minY === maxY ? String(minY) : `${minY}‚Äì${maxY}`;

  // ‚îÄ‚îÄ‚îÄ HEADER with stat cards ‚îÄ‚îÄ‚îÄ
  let h = `<div class="artist-header">
    <div class="artist-hero">
      <div class="artist-photo-wrap" id="artistPhoto"></div>
      <div class="artist-info-side">
        <h2 class="artist-name">${name}</h2>
        <div class="artist-years">Active on ${chartLabel()}: ${yearSpan} &bull; ${validWeekCount()} weeks loaded</div>
        <button class="share-btn" id="shareArtistBtn" onclick="shareArtist('${esc(name)}')" title="Share this artist" style="margin-top:8px">üîó Share</button>
      </div>
    </div>
    <div class="stat-cards">
      <div class="stat-card"><div class="stat-card-icon">${isAlbum ? 'üíø' : 'üéµ'}</div><div class="stat-card-val">${hl.length}</div><div class="stat-card-label">${isAlbum ? 'Chart Albums' : 'Chart Hits'}</div></div>
      <div class="stat-card"><div class="stat-card-icon">üëë</div><div class="stat-card-val gold-text">${n1}</div><div class="stat-card-label">#1 Hits</div></div>
      <div class="stat-card"><div class="stat-card-icon">üî•</div><div class="stat-card-val">${t10}</div><div class="stat-card-label">Top 10</div></div>
      <div class="stat-card"><div class="stat-card-icon">üìà</div><div class="stat-card-val">#${bp}</div><div class="stat-card-label">Highest Peak</div></div>
      <div class="stat-card"><div class="stat-card-icon">üìÖ</div><div class="stat-card-val">${totalWks}</div><div class="stat-card-label">Total Weeks</div></div>
      <div class="stat-card"><div class="stat-card-icon">üéØ</div><div class="stat-card-val">${t40}</div><div class="stat-card-label">Top 40</div></div>
    </div>
  </div>`;

  // Narrative
  h += artistNarrative(name, hl, n1, t10, totalWks, minY, maxY, isAlbum);

  // ‚îÄ‚îÄ‚îÄ CAREER TIMELINE BAR ‚îÄ‚îÄ‚îÄ
  if (years.length >= 1) {
    const tlMin = minY - 1, tlMax = maxY + 1, tlRange = tlMax - tlMin || 1;
    const pct = (y) => ((y - tlMin) / tlRange * 100).toFixed(1);
    const startPct = pct(minY), endPct = pct(maxY);

    h += `<div class="timeline-section">
      <div class="timeline-title">Career Timeline</div>
      <div class="timeline-bar">
        <div class="timeline-active" style="left:${startPct}%;width:${(endPct - startPct) || 1}%"></div>
        <div class="timeline-dots">`;

    // Place dots for each song
    hl.forEach(hit => {
      if (!hit.firstDate) return;
      const yr = +hit.firstDate.substring(0,4);
      const x = pct(yr);
      const isNo1 = hit.peak === 1;
      h += `<div class="timeline-dot${isNo1 ? ' no1' : ''}" style="left:${x}%" title="${hit.title} (${yr}) - #${hit.peak}"></div>`;
    });

    h += `</div></div>
      <div class="timeline-labels">
        <span>${minY}</span>`;
    // Add middle labels
    const midYears = [];
    const step = Math.max(1, Math.floor((maxY - minY) / 4));
    for (let y = minY + step; y < maxY; y += step) midYears.push(y);
    midYears.forEach(y => { h += `<span>${y}</span>`; });
    h += `<span>${maxY}</span></div></div>`;
  }

  // ‚îÄ‚îÄ‚îÄ PEAK POSITION CHART (SVG) ‚îÄ‚îÄ‚îÄ
  if (hl.length >= 2) {
    const chartW = 860, chartH = 180, padL = 36, padR = 16, padT = 10, padB = 24;
    const plotW = chartW - padL - padR, plotH = chartH - padT - padB;
    const maxPeak = Math.max(...hl.map(h => h.peak));
    const scaleY = (peak) => padT + (peak - 1) / Math.max(maxPeak - 1, 1) * plotH;
    const scaleX = (i) => padL + i / (hl.length - 1) * plotW;

    const artChartId = 'artChart' + Date.now();
    h += `<div class="peak-chart" id="${artChartId}">
      <div class="peak-chart-title">Peak Positions Over Time</div>
      <div class="chart-tooltip" id="${artChartId}Tip"></div>
      <svg viewBox="0 0 ${chartW} ${chartH}" preserveAspectRatio="xMidYMid meet">
        <defs>
          <linearGradient id="areaGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="var(--gold)" stop-opacity=".3"/>
            <stop offset="100%" stop-color="var(--gold)" stop-opacity=".02"/>
          </linearGradient>
        </defs>`;

    // Grid lines at #1, #10, #40, #100
    [1, 10, 40, 100].forEach(v => {
      if (v > maxPeak) return;
      const y = scaleY(v);
      h += `<line x1="${padL}" y1="${y}" x2="${chartW - padR}" y2="${y}" stroke="#222" stroke-width="1"/>`;
      h += `<text x="${padL - 6}" y="${y + 4}" fill="#444" font-size="9" text-anchor="end" font-family="DM Mono,monospace">#${v}</text>`;
    });

    // Area fill
    let areaPath = `M${scaleX(0)},${scaleY(hl[0].peak)}`;
    hl.forEach((hit, i) => { if (i > 0) areaPath += ` L${scaleX(i)},${scaleY(hit.peak)}`; });
    areaPath += ` L${scaleX(hl.length-1)},${chartH - padB} L${scaleX(0)},${chartH - padB} Z`;
    h += `<path d="${areaPath}" fill="url(#areaGrad)"/>`;

    // Line
    let linePath = `M${scaleX(0)},${scaleY(hl[0].peak)}`;
    hl.forEach((hit, i) => { if (i > 0) linePath += ` L${scaleX(i)},${scaleY(hit.peak)}`; });
    h += `<path d="${linePath}" fill="none" stroke="var(--gold)" stroke-width="2" stroke-linejoin="round"/>`;

    // Dots
    hl.forEach((hit, i) => {
      const cx = scaleX(i), cy = scaleY(hit.peak);
      const fill = hit.peak === 1 ? 'var(--gold)' : hit.peak <= 10 ? '#fff' : '#888';
      const r = hit.peak === 1 ? 5 : hit.peak <= 10 ? 3.5 : 2.5;
      h += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" stroke="${hit.peak === 1 ? '#111' : 'none'}" stroke-width="${hit.peak === 1 ? 1.5 : 0}"/>`;
      // Label #1 hits
      if (hit.peak === 1) {
        const label = hit.title.length > 18 ? hit.title.substring(0,16) + '‚Ä¶' : hit.title;
        h += `<text x="${cx}" y="${cy - 10}" fill="var(--gold)" font-size="8" text-anchor="middle" font-family="DM Sans,sans-serif" font-weight="700">${label}</text>`;
      }
    });

    // Invisible overlay for mouse/touch tracking
    h += `<rect x="${padL}" y="${padT}" width="${plotW}" height="${plotH}" fill="transparent" style="cursor:crosshair" class="chart-hit-area"/>`;

    // Year labels along bottom
    const seenYears = new Set();
    hl.forEach((hit, i) => {
      if (!hit.firstDate) return;
      const yr = hit.firstDate.substring(0,4);
      if (!seenYears.has(yr)) {
        seenYears.add(yr);
        h += `<text x="${scaleX(i)}" y="${chartH - 4}" fill="#444" font-size="9" text-anchor="middle" font-family="DM Mono,monospace">${yr}</text>`;
      }
    });

    h += `</svg></div>`;

    // Wire up artist chart tooltip
    const _hlData = hl.map((h,i) => ({i, peak: h.peak, title: h.title, year: h.firstDate ? h.firstDate.substring(0,4) : ''}));
    const _hlLen = _hlData.length;
    const _acW = chartW, _apL = padL, _apW = plotW;
    const _artChartId = artChartId;
    setTimeout(() => {
      const container = document.getElementById(_artChartId);
      if (!container) return;
      const svg = container.querySelector('svg');
      const tip = document.getElementById(_artChartId + 'Tip');
      const hitArea = container.querySelector('.chart-hit-area');
      if (!svg || !tip || !hitArea) return;

      function showTip(clientX, clientY) {
        const rect = svg.getBoundingClientRect();
        const relX = (clientX - rect.left) / rect.width;
        const svgX = relX * _acW;
        let nearest = 0, minDist = Infinity;
        for (let j = 0; j < _hlLen; j++) {
          const dotX = _apL + j / Math.max(_hlLen - 1, 1) * _apW;
          const d = Math.abs(svgX - dotX);
          if (d < minDist) { minDist = d; nearest = j; }
        }
        const item = _hlData[nearest];
        const tTitle = item.title.length > 30 ? item.title.substring(0,28) + '‚Ä¶' : item.title;
        tip.innerHTML = '<span class="tt-rank">#' + item.peak + '</span>  ' + tTitle + '<br><span class="tt-date">' + item.year + '</span>';
        tip.classList.add('visible');
        const tipX = (clientX - rect.left) + 14;
        const tipY = (clientY - rect.top) - 36;
        tip.style.left = Math.min(tipX, rect.width - 180) + 'px';
        tip.style.top = Math.max(tipY, 0) + 'px';
      }

      function hideTip() { tip.classList.remove('visible'); }

      hitArea.addEventListener('mousemove', e => showTip(e.clientX, e.clientY));
      hitArea.addEventListener('mouseleave', hideTip);
      hitArea.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; showTip(t.clientX, t.clientY); }, { passive: false });
      hitArea.addEventListener('touchend', hideTip);
    }, 100);
  }

  // ‚îÄ‚îÄ‚îÄ ITEMS GROUPED BY DECADE ‚îÄ‚îÄ‚îÄ
  const decades = new Map();
  hl.forEach(hit => {
    const yr = hit.firstDate ? +hit.firstDate.substring(0,4) : 0;
    const dec = Math.floor(yr / 10) * 10;
    const label = dec < 1960 ? 'Late 50s' : dec + 's';
    if (!decades.has(label)) decades.set(label, []);
    decades.get(label).push(hit);
  });

  const il = itemLabel(false);
  for (const [decLabel, songs] of decades) {
    const decNo1 = songs.filter(s => s.peak === 1).length;
    const decT10 = songs.filter(s => s.peak <= 10).length;
    h += `<div class="decade-group">
      <div class="decade-header">
        <span class="decade-label">${decLabel}</span>
        <div class="decade-line"></div>
        <span class="decade-count">${songs.length} ${songs.length !== 1 ? itemLabel(true) : il}${decNo1 ? ' &bull; ' + decNo1 + ' #1' : ''}${decT10 && !decNo1 ? ' &bull; ' + decT10 + ' top 10' : ''}</span>
      </div>
      <div class="chart-list">`;

    songs.forEach((hit, i) => {
      const tier = hit.peak === 1 ? 'tier-1' : hit.peak <= 10 ? 'tier-2' : 'tier-3';
      const barWidth = Math.max(2, (1 - (hit.peak - 1) / 100) * 100);
      const barColor = hit.peak === 1 ? 'rgba(212,175,55,.10)' : hit.peak <= 10 ? 'rgba(212,175,55,.05)' : 'rgba(255,255,255,.015)';
      const gaugeColor = hit.peak === 1 ? 'var(--gold)' : hit.peak <= 10 ? '#888' : '#444';
      const gaugeW = Math.max(4, (1 - (hit.peak - 1) / 100) * 100);
      const isFeat = hit.creditedAs && hit.creditedAs !== name;
      const featNote = isFeat ? `<span class="artist-hit-feat">as ${hit.creditedAs}</span>` : '';
      const tierBadge = hit.peak === 1 ? '<span class="hit-tier-badge gold">üëë #1</span>'
        : hit.peak <= 10 ? '<span class="hit-tier-badge top10">Top 10</span>'
        : hit.peak <= 40 ? '<span class="hit-tier-badge top40">Top 40</span>' : '';
      const artId = 'hitart_' + decLabel.replace(/\s/g,'') + '_' + i;

      h += `<div class="artist-hit ${tier}" style="animation-delay:${Math.min(i,20)*25}ms">
        <div class="hit-bg-bar" style="width:${barWidth}%;background:${barColor}"></div>
        <div class="artist-hit-art" id="${artId}">
          <div class="art-placeholder">‚ô™</div>
        </div>
        <div class="artist-hit-info">
          <div class="artist-hit-title" onclick="searchFor('${esc(hit.title)}','${esc(hit.creditedAs || name)}')">${hit.title}</div>
          <div class="artist-hit-sub">
            <span class="artist-hit-year">${hit.firstDate ? hit.firstDate.substring(0,4) : ''}</span>
            ${featNote}
            ${tierBadge}
          </div>
          <div class="peak-gauge" style="margin-top:5px">
            <div class="peak-gauge-fill" style="width:${gaugeW}%;background:${gaugeColor}"></div>
          </div>
        </div>
        <div class="artist-hit-right">
          <div class="artist-hit-peak">
            <div class="artist-hit-peak-num">${hit.peak}</div>
            <div class="artist-hit-peak-label">Peak</div>
          </div>
          <div class="artist-hit-weeks">
            <div class="artist-hit-weeks-num">${hit.weeks || '‚Äî'}</div>
            <div class="artist-hit-weeks-label">Wks</div>
          </div>
        </div>
      </div>`;
      if (i < songs.length - 1) h += '<div class="chart-divider"></div>';
    });

    h += '</div></div>';
  }

  // Songwriter/producer credits section (populated async from MusicBrainz)
  h += `<div id="songwriterCredits"></div>`;

  c.innerHTML = h;
  window.scrollTo(0, 0);
  updateHash('artist', name);
  fetchArtistImage(name, 'artistPhoto');
  fetchArtistHitArtwork(name, hl, decades, isAlbum);
  fetchSongwriterCredits(name, 'songwriterCredits');
}

async function fetchArtistHitArtwork(artistName, hits, decades, isAlbum) {
  // iTunes-only, parallel batches. Prefer original LP covers over compilations.

  const delay = ms => new Promise(r => setTimeout(r, ms));
  // Flatten all hits
  const allHits = [];
  for (const [decLabel, songs] of decades) {
    for (let i = 0; i < songs.length; i++) {
      const hit = songs[i];
      const artId = 'hitart_' + decLabel.replace(/\s/g,'') + '_' + i;
      const cacheKey = hit.title + '|||' + (hit.creditedAs || artistName);
      allHits.push({ hit, artId, cacheKey });
    }
  }

  // Render already-cached hits immediately
  const uncached = [];
  for (const item of allHits) {
    if (hitArtData[item.cacheKey]) {
      const el = document.getElementById(item.artId);
      if (el) {
        const d = hitArtData[item.cacheKey];
        el.innerHTML = '<img src="' + d.thumb + '" alt="" loading="lazy">';
      }
    } else {
      uncached.push(item);
    }
  }

  // Batch iTunes lookups ‚Äî 5 at a time
  const BATCH = 5;
  for (let b = 0; b < uncached.length; b += BATCH) {
    const batch = uncached.slice(b, b + BATCH);
    const promises = batch.map(async (item) => {
      try {
        const searchTitle = item.hit.title;
        const creditedArtist = item.hit.creditedAs || artistName;
        const chartYr = item.hit.firstDate ? parseInt(item.hit.firstDate.substring(0,4)) : null;
        const entity = isAlbum ? 'entity=album' : 'entity=song';

        // Try full title first, then first part of slash title if needed
        const titleVariants = [searchTitle];
        if (searchTitle.includes('/')) titleVariants.push(searchTitle.split('/')[0].trim());

        let pick = null;
        for (const tryTitle of titleVariants) {
          const q = encodeURIComponent(tryTitle + ' ' + creditedArtist);
          const r = await fetch('https://itunes.apple.com/search?term=' + q + '&' + entity + '&country=US&limit=15');
          const d = await r.json();
          if (!d.results || !d.results.length) continue;
          pick = pickOriginalAlbumArt(d.results, tryTitle, isAlbum, COMPILATION_RE, NORM_FN, chartYr);
          if (pick && pick.artworkUrl100) break;
        }

        if (pick && pick.artworkUrl100) {
          const thumb = pick.artworkUrl100;
          const full = thumb.replace('100x100', '600x600');
          const el = document.getElementById(item.artId);
          if (el) el.innerHTML = '<img src="' + thumb + '" alt="" loading="lazy">';
          hitArtData[item.cacheKey] = { thumb, full };
          imgCache['song:' + item.hit.title + '|' + (item.hit.creditedAs || artistName)] = full;
        }
      } catch(e) {}
    });
    await Promise.all(promises);
    if (b + BATCH < uncached.length) await delay(150);
  }
}

// Strip iTunes remaster/deluxe/edition tags from album names for display
function cleanAlbumTitle(name) {
  return name
    .replace(/\s*\((?:Remastered|Deluxe|Deluxe Edition|Expanded Edition|Bonus Track Version|Special Edition|Anniversary Edition|Super Deluxe|Remaster|Remasters|\d+(?:th|st|nd|rd)\s*Anniversary.*?)\)\s*/gi, '')
    .replace(/\s*\[(?:Remastered|Deluxe|Expanded|Bonus.*?)\]\s*/gi, '')
    .trim();
}

// Extract label name from iTunes copyright string
// e.g. "‚Ñó 1979 Atlantic Recording Corporation. All Rights Reserved." ‚Üí "Atlantic Recording Corporation"
function cleanCopyright(s) {
  if (!s) return '';
  return s
    .replace(/[^\x20-\x7E]/g, ' ')           // nuke ALL non-ASCII (‚Ñó ¬© etc)
    .replace(/^[\s,;.&]+/, '')                // strip leading punctuation
    .replace(/^\d{4}\s*/, '')                 // strip year
    .replace(/[\s,;.&]+\d{4}\s*/g, ' ')      // strip embedded years
    .replace(/All Rights Reserved.*/i, '')
    .replace(/Marketed by.*/i, '')
    .replace(/Under exclusive.*/i, '')
    .replace(/Distributed by.*/i, '')
    .replace(/,\s*a\s+division\s+of.*/i, '')
    .replace(/,\s*a\s+\w+\s+Music\s+Group\s+Company.*/i, '')
    .replace(/[.,;\s]+$/, '')
    .trim();
}

// Pick the original LP artwork, not a compilation.
// chartYear is when the song/album first charted ‚Äî used to find the contemporary release.
function pickOriginalAlbumArt(results, title, isAlbum, compilationRe, normFn, chartYear) {
  const withArt = results.filter(r => r.artworkUrl100);
  if (!withArt.length) return null;

  const titleNorm = normFn(title);

  // Detect compilations via three signals
  const isComp = r => {
    // 1. iTunes collectionType field
    if ((r.collectionType || '').toLowerCase() === 'compilation') return true;
    // 2. "Various Artists" collection artist
    if ((r.collectionArtistName || '').toLowerCase() === 'various artists') return true;
    // 3. Album name matches compilation patterns
    return compilationRe.test(r.collectionName || '');
  };

  // Score each result
  const scored = withArt.map(r => {
    let score = 0;
    const albumName = normFn(r.collectionName || '');

    // Compilation penalty (heavy)
    if (isComp(r)) score -= 50;

    // Title match bonus ‚Äî album named after the song/album
    if (isAlbum) {
      if (albumName === titleNorm) score += 30;
      else if (albumName.includes(titleNorm) || titleNorm.includes(albumName)) score += 20;
    } else {
      // For songs: bonus if album name contains song title (e.g. "Mr. Natural" song on "Mr. Natural" album)
      if (albumName.includes(titleNorm)) score += 10;
    }

    // Chart year proximity ‚Äî closer to chart year = better
    if (chartYear && r.releaseDate) {
      const relYear = new Date(r.releaseDate).getFullYear();
      const diff = Math.abs(relYear - chartYear);
      if (diff === 0) score += 25;       // Same year ‚Äî almost certainly the right one
      else if (diff === 1) score += 20;   // Off by one year ‚Äî likely right
      else if (diff <= 3) score += 10;    // Close enough
      else score -= diff;                 // Penalize distant releases (reissues, remasters)
    }

    return { r, score };
  });

  // Sort by score descending, then by release date ascending as tiebreaker
  scored.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    return (a.r.releaseDate || '9999').localeCompare(b.r.releaseDate || '9999');
  });

  return scored[0].r;
}


function goToArtist(n) { document.getElementById('artistInput').value = n; switchView('artist'); showArtist(n); }

function goToWeek(date) {
  switchView('weekly');
  if (chartType === 'billboard200') {
    loadAlbumChartWeek(date);
  } else {
    loadChartWeek(date);
  }
}

function searchFor(title, artist) {
  // If we have both title and artist, show the song detail view
  if (title && artist) {
    showSong(title, artist);
    return;
  }
  // Otherwise fall back to search
  document.getElementById('searchInput').value = title;
  searchFilter = 'song';
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.toggle('active', b.dataset.filter === 'song'));
  switchView('search');
  doSearch();
}

function showSong(title, artist) {
  // Find every week this song/album appeared on the chart
  const cache = activeCache();
  const isAlbum = chartType === 'billboard200';
  const weeks = [];
  const titleNorm = stripAccents(title).toLowerCase();
  const artistNorm = stripAccents(artist).toLowerCase();
  let matchedTitle = title, matchedArtist = artist; // track actual CSV name

  for (const [date, entries] of Object.entries(cache)) {
    if (!Array.isArray(entries)) continue;
    try {
      for (const e of entries) {
        if (!e) continue;
        // Exact match first, then accent-insensitive fallback
        const titleMatch = e.title === title || stripAccents(e.title).toLowerCase() === titleNorm;
        const artistMatch = e.artist === artist || stripAccents(e.artist).toLowerCase() === artistNorm;
        if (titleMatch && artistMatch) {
          weeks.push({ date, rank: e.rank, lastWeek: e.lastWeek, peak: e.peak, weeks: e.weeks });
          // Use CSV's actual name for display consistency
          if (e.title !== title) matchedTitle = e.title;
          if (e.artist !== artist) matchedArtist = e.artist;
        }
      }
    } catch(err) {}
  }

  // If found under a different spelling, use that for display
  if (weeks.length > 0) { title = matchedTitle; artist = matchedArtist; }

  // Clean display title for albums (strip Remastered/Deluxe etc)
  const displayTitle = isAlbum ? cleanAlbumTitle(title) : title;

  weeks.sort((a, b) => a.date.localeCompare(b.date));

  const peakPos = weeks.length ? Math.min(...weeks.map(w => w.rank || 999)) : 0;
  const maxWks = weeks.length ? Math.max(...weeks.map(w => w.weeks || 0)) : 0;
  const peakWeek = weeks.find(w => w.rank === peakPos);
  const hasChartData = weeks.length > 0 && peakPos > 0;

  // Build list of all entries by this artist for prev/next navigation
  const artistEntries = new Map(); // title -> { firstDate }
  for (const [date, entries] of Object.entries(cache)) {
    if (!Array.isArray(entries)) continue;
    for (const e of entries) {
      if (!e || !e.artist) continue;
      if (!artistMatches(e.artist, artist)) continue;
      const key = e.title;
      if (!artistEntries.has(key)) {
        artistEntries.set(key, { title: e.title, artist: e.artist, firstDate: date });
      } else {
        const ex = artistEntries.get(key);
        if (date < ex.firstDate) ex.firstDate = date;
      }
    }
  }
  // Sort by first chart date
  const sortedEntries = [...artistEntries.values()].sort((a, b) => a.firstDate.localeCompare(b.firstDate));
  const currentIdx = sortedEntries.findIndex(e => e.title === title);
  const prevEntry = currentIdx > 0 ? sortedEntries[currentIdx - 1] : null;
  const nextEntry = currentIdx >= 0 && currentIdx < sortedEntries.length - 1 ? sortedEntries[currentIdx + 1] : null;
  _navPrev = prevEntry; _navNext = nextEntry;

  const c = document.getElementById('songContent');
  let h = `<div class="breadcrumb">
    <a onclick="switchView('weekly')">Charts</a><span class="sep">‚Ä∫</span>
    ${currentDate ? `<a onclick="goToWeek('${currentDate}')">${fmtDate(currentDate)}</a><span class="sep">‚Ä∫</span>` : ''}
    <span class="current">${displayTitle}</span>
    <button class="share-btn" id="shareSongBtn" onclick="shareSong('${esc(title)}','${esc(artist)}')" title="Share this song" style="margin-left:auto">üîó Share</button>
  </div>`;

  h += `<div class="song-header">
    <div class="song-hero">
      <div class="song-art-wrap" id="songArt"></div>
      <div class="song-info-side">
        <div class="song-title-big">${displayTitle}</div>
        <div class="song-artist-big" onclick="goToArtist('${esc(artist)}')">${artist}</div>
        ${hasChartData ? `<div class="song-stats-row">
          <div><div class="artist-stat-val">#${peakPos}</div><div class="artist-stat-label">Peak Position</div></div>
          <div><div class="artist-stat-val">${maxWks}</div><div class="artist-stat-label">Weeks on Chart</div></div>
          <div><div class="artist-stat-val">${weeks.length}</div><div class="artist-stat-label">Weeks Found</div></div>
          ${peakWeek ? `<div><div class="artist-stat-val" style="font-size:16px">${fmtDate(peakWeek.date)}</div><div class="artist-stat-label">Reached #${peakPos}</div></div>` : ''}
        </div>` : (isAlbum && !b200Loaded ? `<div style="margin-top:12px"><button class="b200-load-btn" style="font-size:12px;padding:6px 14px" onclick="loadB200ThenRefresh('${esc(title)}','${esc(artist)}')">Load Billboard 200 Data</button><div id="albumInlineProgress" style="margin-top:6px;font-size:11px;color:var(--text-faint)"></div></div>` : `<div style="margin-top:10px;font-size:12px;color:var(--text-faint)">${isAlbum ? 'Album not found in Billboard 200 data' : 'No Hot 100 chart data loaded for this song'}</div>`)}
      </div>
    </div>
  </div>`;

  // Narrative
  h += songNarrative(title, artist, weeks, peakPos, maxWks, isAlbum);

  // Enriched narrative (populated async by credits, chart peaks, album link)
  if (!isAlbum && hasChartData) {
    h += `<div id="songEnrichment" class="narrative enrichment"></div>`;
    _songEnrichment = { title, artist, peakPos, weeks: maxWks || weeks.length, credits: null, chartPeaks: null, albumInfo: null };
  } else {
    _songEnrichment = null;
  }

  // Artist entry navigation (prev/next)
  if (sortedEntries.length > 1 && currentIdx >= 0) {
    const pos = `${currentIdx + 1} of ${sortedEntries.length}`;
    h += `<div class="artist-entry-nav">`;
    if (prevEntry) {
      const pTitle = isAlbum ? cleanAlbumTitle(prevEntry.title) : prevEntry.title;
      const pShort = pTitle.length > 30 ? pTitle.substring(0, 28) + '‚Ä¶' : pTitle;
      h += `<button class="entry-nav-btn" onclick="showSong('${esc(prevEntry.title)}','${esc(prevEntry.artist)}')"><span class="entry-nav-arrow">‚Äπ</span><span class="entry-nav-label">${pShort}</span></button>`;
    } else {
      h += `<div class="entry-nav-spacer"></div>`;
    }
    h += `<span class="entry-nav-pos" onclick="goToArtist('${esc(artist)}')">${pos}</span>`;
    if (nextEntry) {
      const nTitle = isAlbum ? cleanAlbumTitle(nextEntry.title) : nextEntry.title;
      const nShort = nTitle.length > 30 ? nTitle.substring(0, 28) + '‚Ä¶' : nTitle;
      h += `<button class="entry-nav-btn entry-nav-next" onclick="showSong('${esc(nextEntry.title)}','${esc(nextEntry.artist)}')"><span class="entry-nav-label">${nShort}</span><span class="entry-nav-arrow">‚Ä∫</span></button>`;
    } else {
      h += `<div class="entry-nav-spacer"></div>`;
    }
    h += `</div>`;
  }

  // Credits placeholder (filled async by MusicBrainz) - songs only
  if (!isAlbum) h += `<div id="songCredits"></div>`;

  // Album link placeholder (from B200 cross-reference) - songs only
  if (!isAlbum) h += `<div id="songAlbumLink"></div>`;

  // Billboard chart peaks placeholder (filled async by Wikipedia)
  if (!isAlbum) h += `<div id="songChartPeaks"></div>`;

  // Album: track list + credits + singles + chart peaks placeholders
  if (isAlbum) {
    h += `<div id="albumTracks"></div>`;
    h += `<div id="albumCredits"></div>`;
    h += `<div id="albumChartPeaks"></div>`;
    h += `<div id="albumSingles"></div>`;
  }

  if (weeks.length === 0 && !isAlbum) {
    h += `<div class="empty"><div class="empty-icon">üîá</div><p>No weekly data found</p><p class="sub">Load more decades for a complete chart run</p></div>`;
  } else if (weeks.length > 0) {
    // ‚îÄ‚îÄ‚îÄ CHART POSITION LINE GRAPH ‚îÄ‚îÄ‚îÄ
    if (weeks.length >= 2) {
      // Find other entries by same artist on chart during these weeks
      const siblingColors = ['#5b8abd','#b05ca6','#5bbd7a','#bd7a5b','#8a8abd'];
      const siblingMap = {}; // { title: { date: rank, ... } }
      const weekDates = new Set(weeks.map(w => w.date));
      for (const date of weekDates) {
        const entries = cache[date];
        if (!Array.isArray(entries)) continue;
        for (const e of entries) {
          if (!e || !e.artist || !e.title) continue;
          if (e.artist === artist && e.title !== title) {
            if (!siblingMap[e.title]) siblingMap[e.title] = {};
            siblingMap[e.title][date] = e.rank;
          }
        }
      }
      // Convert to array sorted by most weeks on chart, limit to 5
      const siblings = Object.entries(siblingMap)
        .map(([t, dates]) => ({ title: t, dates }))
        .sort((a, b) => Object.keys(b.dates).length - Object.keys(a.dates).length)
        .slice(0, 5);

      const chartW = 860, chartH = 200, padL = 38, padR = 16, padT = 14, padB = 28;
      const plotW = chartW - padL - padR, plotH = chartH - padT - padB;
      // Include sibling ranks in maxR so scale covers everything
      let allRanks = weeks.map(w => w.rank || 100);
      siblings.forEach(s => { Object.values(s.dates).forEach(r => allRanks.push(r)); });
      const maxR = Math.max(...allRanks);
      const chartMax = isAlbum ? 200 : 100;
      const scaleY = (rank) => padT + (rank - 1) / Math.max(maxR - 1, 1) * plotH;
      const scaleX = (i) => padL + i / (weeks.length - 1) * plotW;

      const chartId = 'posChart' + Date.now();
      h += `<div class="peak-chart" id="${chartId}">
        <div class="peak-chart-title">Chart Position</div>
        <div class="chart-tooltip" id="${chartId}Tip"></div>
        <svg viewBox="0 0 ${chartW} ${chartH}" preserveAspectRatio="xMidYMid meet">
          <defs>
            <linearGradient id="songAreaGrad" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stop-color="var(--gold)" stop-opacity=".35"/>
              <stop offset="100%" stop-color="var(--gold)" stop-opacity=".02"/>
            </linearGradient>
          </defs>`;

      // Grid lines
      const gridVals = isAlbum ? [1, 10, 20, 40, 60, 80, 100, 150, 200] : [1, 10, 20, 40, 60, 80, 100];
      gridVals.forEach(v => {
        if (v > maxR) return;
        const y = scaleY(v);
        h += `<line x1="${padL}" y1="${y}" x2="${chartW - padR}" y2="${y}" stroke="#222" stroke-width="1"/>`;
        h += `<text x="${padL - 6}" y="${y + 4}" fill="#444" font-size="9" text-anchor="end" font-family="DM Mono,monospace">#${v}</text>`;
      });

      // ‚îÄ‚îÄ‚îÄ Sibling lines (drawn first so they appear behind) ‚îÄ‚îÄ‚îÄ
      siblings.forEach((sib, si) => {
        const color = siblingColors[si % siblingColors.length];
        // Build segments (only draw where sibling is on chart)
        let segments = [], seg = [];
        weeks.forEach((w, i) => {
          const r = sib.dates[w.date];
          if (r !== undefined) {
            seg.push({ i, rank: r });
          } else {
            if (seg.length > 1) segments.push(seg);
            seg = [];
          }
        });
        if (seg.length > 1) segments.push(seg);

        // Draw each continuous segment
        segments.forEach(pts => {
          let path = `M${scaleX(pts[0].i)},${scaleY(pts[0].rank)}`;
          for (let k = 1; k < pts.length; k++) {
            path += ` L${scaleX(pts[k].i)},${scaleY(pts[k].rank)}`;
          }
          h += `<path d="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-opacity=".4" stroke-linejoin="round" stroke-dasharray="4,3"/>`;
        });

        // Small dots at each point
        weeks.forEach((w, i) => {
          const r = sib.dates[w.date];
          if (r !== undefined) {
            h += `<circle cx="${scaleX(i)}" cy="${scaleY(r)}" r="2" fill="${color}" fill-opacity=".5"/>`;
          }
        });
      });

      // ‚îÄ‚îÄ‚îÄ Main entry area fill ‚îÄ‚îÄ‚îÄ
      let areaPath = `M${scaleX(0)},${scaleY(weeks[0].rank)}`;
      weeks.forEach((w, i) => { if (i > 0) areaPath += ` L${scaleX(i)},${scaleY(w.rank)}`; });
      areaPath += ` L${scaleX(weeks.length-1)},${chartH - padB} L${scaleX(0)},${chartH - padB} Z`;
      h += `<path d="${areaPath}" fill="url(#songAreaGrad)"/>`;

      // ‚îÄ‚îÄ‚îÄ Main entry line ‚îÄ‚îÄ‚îÄ
      let linePath = `M${scaleX(0)},${scaleY(weeks[0].rank)}`;
      weeks.forEach((w, i) => { if (i > 0) linePath += ` L${scaleX(i)},${scaleY(w.rank)}`; });
      h += `<path d="${linePath}" fill="none" stroke="var(--gold)" stroke-width="2.5" stroke-linejoin="round" stroke-linecap="round"/>`;

      // Dots + peak label
      weeks.forEach((w, i) => {
        const cx = scaleX(i), cy = scaleY(w.rank);
        const isP = w.rank === peakPos;
        const fill = w.rank === 1 ? 'var(--gold)' : w.rank <= 10 ? '#fff' : '#aaa';
        const r = isP ? 5 : w.rank <= 10 ? 3.5 : 2.5;
        h += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" stroke="${isP ? '#111' : 'none'}" stroke-width="${isP ? 1.5 : 0}"/>`;
        if (isP && i === weeks.indexOf(weeks.find(wk => wk.rank === peakPos))) {
          h += `<text x="${cx}" y="${cy - 10}" fill="var(--gold)" font-size="10" text-anchor="middle" font-family="DM Mono,monospace" font-weight="700">#${peakPos}</text>`;
        }
      });

      // Invisible overlay for mouse/touch tracking
      h += `<rect x="${padL}" y="${padT}" width="${plotW}" height="${plotH}" fill="transparent" style="cursor:crosshair" class="chart-hit-area"/>`;

      // Week labels along bottom
      const labelStep = weeks.length <= 12 ? 1 : weeks.length <= 26 ? 2 : Math.ceil(weeks.length / 12);
      weeks.forEach((w, i) => {
        if (i % labelStep === 0 || i === weeks.length - 1) {
          const label = w.date.substring(5, 10).replace('-', '/');
          h += `<text x="${scaleX(i)}" y="${chartH - 6}" fill="#444" font-size="8" text-anchor="middle" font-family="DM Mono,monospace">${label}</text>`;
        }
      });

      h += `</svg>`;

      // Legend for siblings
      if (siblings.length > 0) {
        h += `<div style="display:flex;flex-wrap:wrap;gap:10px 16px;margin-top:8px;padding:0 4px">`;
        h += `<span style="font-size:10px;color:#666;display:flex;align-items:center;gap:4px"><span style="display:inline-block;width:12px;height:3px;background:var(--gold);border-radius:1px"></span> ${title.length > 30 ? title.substring(0,28)+'‚Ä¶' : title}</span>`;
        siblings.forEach((sib, si) => {
          const color = siblingColors[si % siblingColors.length];
          const sTitle = sib.title.length > 30 ? sib.title.substring(0,28)+'‚Ä¶' : sib.title;
          h += `<span style="font-size:10px;color:#666;display:flex;align-items:center;gap:4px;cursor:pointer" onclick="showSong('${esc(sib.title)}','${esc(artist)}')"><span style="display:inline-block;width:12px;height:3px;background:${color};opacity:.6;border-radius:1px"></span> ${sTitle}</span>`;
        });
        h += `</div>`;
      }

      h += `</div>`;

      // Wire up tooltip after render (with sibling data)
      const _weekData = weeks.map((w,i) => ({i, rank: w.rank, date: w.date, wk: i+1}));
      const _sibData = siblings.map((s,si) => ({
        title: s.title,
        color: siblingColors[si % siblingColors.length],
        dates: s.dates
      }));
      const _wLen = _weekData.length;
      const _cW = chartW, _pL = padL, _pW = plotW;
      const _chartId = chartId;
      setTimeout(() => {
        const container = document.getElementById(_chartId);
        if (!container) return;
        const svg = container.querySelector('svg');
        const tip = document.getElementById(_chartId + 'Tip');
        const hitArea = container.querySelector('.chart-hit-area');
        if (!svg || !tip || !hitArea) return;

        function showTip(clientX, clientY) {
          const rect = svg.getBoundingClientRect();
          const relX = (clientX - rect.left) / rect.width;
          const svgX = relX * _cW;
          let nearest = 0, minDist = Infinity;
          for (let j = 0; j < _wLen; j++) {
            const dotX = _pL + j / Math.max(_wLen - 1, 1) * _pW;
            const d = Math.abs(svgX - dotX);
            if (d < minDist) { minDist = d; nearest = j; }
          }
          const w = _weekData[nearest];
          let html = '<span class="tt-rank">#' + w.rank + '</span>  Week ' + w.wk;
          // Show siblings at this date
          for (const s of _sibData) {
            const sr = s.dates[w.date];
            if (sr !== undefined) {
              const st = s.title.length > 22 ? s.title.substring(0,20)+'‚Ä¶' : s.title;
              html += '<br><span style="color:' + s.color + ';font-size:10px">#' + sr + ' ' + st + '</span>';
            }
          }
          html += '<br><span class="tt-date">' + w.date + '</span>';
          tip.innerHTML = html;
          tip.classList.add('visible');
          const tipX = (clientX - rect.left) + 14;
          const tipY = (clientY - rect.top) - 36;
          tip.style.left = Math.min(tipX, rect.width - 160) + 'px';
          tip.style.top = Math.max(tipY, 0) + 'px';
        }

        function hideTip() { tip.classList.remove('visible'); }

        hitArea.addEventListener('mousemove', e => showTip(e.clientX, e.clientY));
        hitArea.addEventListener('mouseleave', hideTip);
        hitArea.addEventListener('touchmove', e => {
          e.preventDefault();
          const t = e.touches[0];
          showTip(t.clientX, t.clientY);
        }, { passive: false });
        hitArea.addEventListener('touchend', hideTip);
      }, 100);
    }

    h += `<div class="sort-label">Week-by-week chart run &bull; ${weeks.length} weeks found</div>`;
    h += '<div class="chart-list">';

    // Pre-scan: find all other entries by this artist for each week date
    const companionMap = {};
    for (const w of weeks) {
      const dateEntries = cache[w.date];
      if (!Array.isArray(dateEntries)) continue;
      const others = [];
      for (const e of dateEntries) {
        if (!e || !e.artist || !e.title) continue;
        if (e.title === title && e.artist === artist) continue; // skip self
        if (artistMatches(e.artist, artist)) {
          others.push({ title: e.title, rank: e.rank, artist: e.artist });
        }
      }
      // Sort by rank
      others.sort((a, b) => a.rank - b.rank);
      companionMap[w.date] = others;
    }

    weeks.forEach((w, i) => {
      const cls = w.rank === 1 ? 'gold' : w.rank <= 3 ? 'silver' : w.rank <= 10 ? 'top10' : 'normal';
      const lw = w.lastWeek;
      let mi = 'NEW', mc = 'new';
      if (lw) {
        const diff = lw - w.rank;
        if (diff > 0) { mi = '‚ñ≤' + diff; mc = 'up'; }
        else if (diff < 0) { mi = '‚ñº' + Math.abs(diff); mc = 'down'; }
        else { mi = '‚Äî'; mc = 'same'; }
      }

      // Build companion pills
      const companions = companionMap[w.date] || [];
      let compHtml = '';
      if (companions.length > 0) {
        compHtml = '<div class="week-companions">';
        for (const c of companions.slice(0, 4)) {
          const shortTitle = c.title.length > 22 ? c.title.substring(0, 20) + '‚Ä¶' : c.title;
          compHtml += `<span class="companion-pill" onclick="searchFor('${esc(c.title)}','${esc(c.artist)}')" title="${c.title} (#${c.rank})"><span class="comp-rank">#${c.rank}</span>${shortTitle}</span>`;
        }
        if (companions.length > 4) compHtml += `<span class="companion-pill" style="color:#555">+${companions.length - 4} more</span>`;
        compHtml += '</div>';
      }

      h += `<div class="week-row" style="animation-delay:${Math.min(i,25)*20}ms">
        <div class="rank-badge ${cls}">${w.rank}</div>
        <div class="week-date" onclick="goToWeek('${w.date}')">${fmtDate(w.date)}</div>
        <div class="entry-stats">
          ${lw ? `<div class="stat-col"><div class="stat-header">LW</div><div class="stat-val">${lw}</div></div>` : '<div class="stat-col"><div class="stat-header">LW</div><div class="stat-val">‚Äî</div></div>'}
          ${w.peak ? `<div class="stat-col"><div class="stat-header">PK</div><div class="stat-val">${w.peak}</div></div>` : ''}
          ${w.weeks ? `<div class="stat-col"><div class="stat-header">WK</div><div class="stat-val">${w.weeks}</div></div>` : ''}
          <div class="move-badge ${mc}">${mi}</div>
        </div>
        ${compHtml}
      </div>`;
      if (i < weeks.length - 1) h += '<div class="chart-divider"></div>';
    });
    h += '</div>';
  }

  c.innerHTML = h;
  switchView('song');
  updateHash('song', title, artist);
  window.scrollTo(0, 0);
  // Fetch album art async (for both songs and albums)
  const chartYear = weeks.length ? parseInt(weeks[0].date.substring(0,4)) : null;
  fetchSongImage(title, artist, 'songArt', chartYear);
  // Fetch credits only for songs
  if (!isAlbum) fetchSongCredits(title, artist, 'songCredits');
  // Find parent album from B200 data - songs only
  if (!isAlbum) findSongAlbum(title, artist, 'songAlbumLink', chartYear);
  // Fetch Billboard chart peaks from Wikipedia
  if (!isAlbum) fetchChartPeaks(title, artist, 'songChartPeaks', false);
  // Fetch track list + credits + chart peaks + singles for albums
  if (isAlbum) {
    const albumYear = weeks.length ? +weeks[0].date.substring(0,4) : 0;
    fetchAlbumTracks(title, artist, albumYear, 'albumTracks', weeks);
    fetchAlbumCredits(title, artist, albumYear, 'albumCredits');
    fetchChartPeaks(title, artist, 'albumChartPeaks', true);
  }
}

// ‚îÄ‚îÄ‚îÄ SONG ‚Üí ALBUM LINK (B200 cross-reference) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let _navPrev = null, _navNext = null; // for keyboard artist entry nav
let _pendingAlbumContext = null; // set by viewSingleFromAlbum
const songAlbumCache = {}; // songTitle|artist -> album info or null

async function findSongAlbum(songTitle, artist, elementId, chartYear) {
  const el = document.getElementById(elementId);
  if (!el) return;

  const norm = s => stripAccents(s).toLowerCase().replace(/[^a-z0-9]/g, '');
  const cacheKey = songTitle + '|' + artist;

  // Check cache
  if (songAlbumCache[cacheKey] !== undefined) {
    if (songAlbumCache[cacheKey]) { renderAlbumLink(el, songAlbumCache[cacheKey]); updateSongEnrichment('albumInfo', songAlbumCache[cacheKey]); }
    else el.innerHTML = '';
    return;
  }

  // Collect candidate albums from B200 cache for enrichment
  const b200Albums = new Map();
  for (const [date, entries] of Object.entries(albumCache)) {
    if (!Array.isArray(entries)) continue;
    for (const e of entries) {
      if (!e || !e.artist || !e.title) continue;
      if (!artistMatches(e.artist, artist)) continue;
      const key = e.title.toLowerCase();
      if (!b200Albums.has(key)) {
        b200Albums.set(key, { title: e.title, artist: e.artist, peak: e.rank, weeks: 1, firstDate: date });
      } else {
        const a = b200Albums.get(key);
        a.weeks++;
        if (e.rank < a.peak) a.peak = e.rank;
        if (date < a.firstDate) a.firstDate = date;
      }
    }
  }

  // Path 1: Pending context from album page click-through
  if (_pendingAlbumContext) {
    const ctx = _pendingAlbumContext;
    _pendingAlbumContext = null;
    const b200 = b200Albums.get(ctx.albumTitle.toLowerCase());
    const result = {
      title: ctx.albumTitle,
      artist: ctx.albumArtist,
      peak: b200 ? b200.peak : 0,
      weeks: b200 ? b200.weeks : 0,
      artUrl: null
    };
    songAlbumCache[cacheKey] = result;
    renderAlbumLink(el, result);
    updateSongEnrichment('albumInfo', result);
    fetchAlbumLinkArt(result, el);
    return;
  }

  // Path 2: iTunes song search ‚Äî returns collectionName (album) for each track
  el.innerHTML = '';

  try {
    // Try full title first, then first part of slash title if needed
    const titleVariants = [songTitle];
    if (songTitle.includes('/')) titleVariants.push(songTitle.split('/')[0].trim());

    let bestMatch = null, bestScore = -Infinity;

    for (const tryTitle of titleVariants) {
      const q = encodeURIComponent(tryTitle + ' ' + artist);
      const url = `https://itunes.apple.com/search?term=${q}&entity=song&country=US&limit=15`;
      const r = await fetch(url);
      if (!r.ok) continue;
      const data = await r.json();
      if (!data.results || data.results.length === 0) continue;

      const songNorm = norm(tryTitle);
      const artistNorm = norm(artist);

      // Find matching tracks ‚Äî filter for correct song + artist
      for (const t of data.results) {
        const tTitle = norm(t.trackName || '');
        const tArtist = norm(t.artistName || '');
        const tAlbum = t.collectionName || '';

        // Must match song title
        if (tTitle !== songNorm && !tTitle.includes(songNorm) && !songNorm.includes(tTitle)) continue;
        // Must match artist
        if (!tArtist.includes(artistNorm) && !artistNorm.includes(tArtist)) continue;

        let score = 0;
        if (tTitle === songNorm) score += 5;
        if (tArtist === artistNorm) score += 3;
      // Prefer non-compilation albums (check both collectionType and name)
      const isComp = (t.collectionType || '').toLowerCase() === 'compilation' ||
                     (t.collectionArtistName || '').toLowerCase() === 'various artists' ||
                     COMPILATION_RE.test(tAlbum);
      if (isComp) score -= 30;
      // Penalize live albums
      const isLive = /\b(live at|live in|live from|in concert|unplugged|mtv unplugged)\b/i.test(tAlbum) ||
                     (/\blive\b/i.test(tAlbum) && /\b(encore|more|tour|concert|stage|performance|recorded)\b/i.test(tAlbum)) ||
                     (/\bencore\b/i.test(tAlbum) && /\b(live|presents|more)\b/i.test(tAlbum));
      if (isLive) score -= 25;
      // Prefer albums that exist in B200 data
      if (b200Albums.has(tAlbum.toLowerCase())) score += 15;
      // Chart-year proximity scoring (same as pickOriginalAlbumArt)
      if (chartYear && t.releaseDate) {
        const albumYear = new Date(t.releaseDate).getFullYear();
        const diff = Math.abs(albumYear - chartYear);
        if (diff === 0) score += 25;
        else if (diff === 1) score += 20;
        else if (diff <= 3) score += 10;
        else score -= diff * 2;
      }

      if (score > bestScore) { bestScore = score; bestMatch = t; }
      }
      // If we found a good non-compilation match, stop trying variants
      if (bestMatch && bestScore > 0) break;
    }

    if (!bestMatch || !bestMatch.collectionName) throw 'no-match';

    const albumTitle = cleanAlbumTitle(bestMatch.collectionName);
    const b200 = b200Albums.get(albumTitle.toLowerCase()) || b200Albums.get(bestMatch.collectionName.toLowerCase());
    const artUrl = bestMatch.artworkUrl100 ? bestMatch.artworkUrl100.replace('100x100', '200x200') : null;

    const result = {
      title: albumTitle,
      artist: bestMatch.artistName || artist,
      peak: b200 ? b200.peak : 0,
      weeks: b200 ? b200.weeks : 0,
      artUrl
    };
    songAlbumCache[cacheKey] = result;
    renderAlbumLink(el, result);
    updateSongEnrichment('albumInfo', result);

  } catch(e) {
    songAlbumCache[cacheKey] = null;
    el.innerHTML = '';
  }
}

function renderAlbumLink(el, album) {
  const displayTitle = cleanAlbumTitle(album.title);
  const peakStr = album.peak > 0 ? `#${album.peak} on Billboard 200` : '';
  const weeksStr = album.weeks > 0 ? `${album.weeks} wk${album.weeks !== 1 ? 's' : ''}` : '';
  const meta = [peakStr, weeksStr].filter(Boolean).join(' ¬∑ ');
  const artHtml = album.artUrl ? `<img src="${album.artUrl}" alt="">` : 'üíø';

  el.innerHTML = `<div class="song-album-link" onclick="goToAlbumFromSong('${esc(album.title)}','${esc(album.artist)}')">
    <div class="song-album-art">${artHtml}</div>
    <div class="song-album-info">
      <div class="song-album-label">From the LP</div>
      <div class="song-album-name">${displayTitle}</div>
      ${meta ? `<div class="song-album-meta">${meta}</div>` : ''}
    </div>
    <div class="song-album-arrow">‚Ä∫</div>
  </div>`;
}

async function fetchAlbumLinkArt(result, containerEl) {
  if (result.artUrl) return;

  const hitKey = result.title + '|||' + result.artist;
  if (hitArtData[hitKey]) {
    result.artUrl = hitArtData[hitKey].full || hitArtData[hitKey].thumb;
    renderAlbumLink(containerEl, result);
    return;
  }

  try {
    const q = encodeURIComponent(result.title + ' ' + result.artist);
    const r = await fetch('https://itunes.apple.com/search?term=' + q + '&entity=album&country=US&limit=15');
    if (!r.ok) return;
    const data = await r.json();
    if (!data.results || data.results.length === 0) return;

    const chartYear = result.firstDate ? parseInt(result.firstDate.substring(0,4)) : null;
    const pick = pickOriginalAlbumArt(data.results, result.title, true, COMPILATION_RE, NORM_FN, chartYear);
    if (pick && pick.artworkUrl100) {
      result.artUrl = pick.artworkUrl100.replace('100x100', '200x200');
      renderAlbumLink(containerEl, result);
    }
  } catch(e) {}
}

function goToAlbumFromSong(albumTitle, artist) {
  // Switch to Billboard 200 and show the album
  chartType = 'billboard200';
  document.querySelectorAll('.chart-type-btn').forEach(b => {
    b.classList.toggle('active', b.textContent.includes('200'));
  });
  showSong(albumTitle, artist);
}

// Load B200 data from an album detail page, then refresh
async function loadB200ThenRefresh(albumTitle, artist) {
  if (b200Loading || b200Loaded) return;
  b200Loading = true;

  const prog = document.getElementById('albumInlineProgress');
  const btn = event && event.target;
  if (btn) { btn.disabled = true; btn.textContent = 'Downloading...'; }
  if (prog) prog.textContent = 'Downloading Billboard 200 data...';

  try {
    if (typeof Papa === 'undefined') throw new Error('CSV parser not loaded');

    const response = await fetch(B200_CSV);
    if (!response.ok) throw new Error('HTTP ' + response.status);
    if (prog) prog.textContent = 'Reading response...';

    const csvText = await response.text();
    if (prog) prog.textContent = 'Parsing ' + (csvText.length / 1048576).toFixed(1) + ' MB...';

    const tempCache = {};
    let rowCount = 0, headerParsed = false;
    let dateIdx, rankIdx, titleIdx, artistIdx, lwIdx, peakIdx, wksIdx;

    Papa.parse(csvText, {
      header: false, skipEmptyLines: true,
      step: function(result) {
        const row = result.data;
        if (!row || row.length < 4) return;
        if (!headerParsed) {
          const h = row.map(c => (c || '').trim().toLowerCase());
          dateIdx = h.indexOf('chart_date'); if (dateIdx < 0) dateIdx = h.indexOf('chart week'); if (dateIdx < 0) dateIdx = h.indexOf('chart_week');
          rankIdx = h.indexOf('current_rank'); if (rankIdx < 0) rankIdx = h.indexOf('this week'); if (rankIdx < 0) rankIdx = h.indexOf('this_week');
          titleIdx = h.indexOf('title'); if (titleIdx < 0) titleIdx = h.indexOf('album');
          artistIdx = h.indexOf('artist'); if (artistIdx < 0) artistIdx = h.indexOf('performer');
          lwIdx = h.indexOf('last_week'); if (lwIdx < 0) lwIdx = h.indexOf('last week');
          peakIdx = h.indexOf('peak_position'); if (peakIdx < 0) peakIdx = h.indexOf('peak position'); if (peakIdx < 0) peakIdx = h.indexOf('peak_pos');
          wksIdx = h.indexOf('weeks_on_chart'); if (wksIdx < 0) wksIdx = h.indexOf('wks on chart'); if (wksIdx < 0) wksIdx = h.indexOf('weeks');
          if (dateIdx < 0 || rankIdx < 0 || titleIdx < 0 || artistIdx < 0) { dateIdx=0; rankIdx=3; titleIdx=1; artistIdx=2; lwIdx=4; peakIdx=5; wksIdx=6; }
          headerParsed = true;
          return;
        }
        var d = (row[dateIdx]||'').trim(), rk = parseInt(row[rankIdx]);
        if (!d || isNaN(rk)) return;
        d = d.replace(/\//g, '-');
        if (!tempCache[d]) tempCache[d] = [];
        tempCache[d].push({ rank: rk, title: (row[titleIdx]||'').trim(), artist: (row[artistIdx]||'').trim(),
          lastWeek: lwIdx >= 0 ? parseInt(row[lwIdx]) || null : null,
          peak: peakIdx >= 0 ? parseInt(row[peakIdx]) || null : null,
          weeks: wksIdx >= 0 ? parseInt(row[wksIdx]) || null : null });
        rowCount++;
      }
    });

    albumCache = tempCache;
    const dates = Object.keys(albumCache).sort();
    albumDates = dates;
    filteredAlbumDates = dates;

    // Save to IndexedDB
    for (let j = 0; j < dates.length; j++) {
      dbPut(dates[j], albumCache[dates[j]], STORE_ALBUM);
    }

    b200Loaded = true;
    b200Loading = false;

    if (prog) prog.textContent = '‚úÖ ' + rowCount.toLocaleString() + ' entries loaded!';

    // Refresh the album page with real data
    setTimeout(() => showSong(albumTitle, artist), 300);

  } catch(e) {
    b200Loading = false;
    if (btn) { btn.disabled = false; btn.textContent = 'Load Billboard 200 Data'; }
    if (prog) prog.textContent = '‚ùå Error: ' + e.message;
  }
}

// ‚îÄ‚îÄ‚îÄ BILLBOARD CHART PEAKS (Wikipedia) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const chartPeaksCache = {};

async function fetchChartPeaks(title, artist, elementId, isAlbum) {
  const el = document.getElementById(elementId);
  if (!el) return;

  const key = (isAlbum ? 'album:' : '') + title + '|' + artist;
  if (chartPeaksCache[key]) { renderChartPeaks(el, chartPeaksCache[key], isAlbum); return; }
  if (chartPeaksCache[key] === null) { el.innerHTML = ''; return; } // previously failed

  el.innerHTML = `<div class="chart-peaks-section loading"><div class="chart-peaks-title"><span class="cp-icon">üìä</span> Billboard Chart Peaks</div><div style="font-size:12px;color:var(--text-faint)">Looking up chart positions...</div></div>`;

  try {
    // Try Wikipedia page with common disambiguation patterns
    const artistFirst = artist.split(/\s+(featuring|feat\.?|ft\.?|and|&|with|x)\s+/i)[0].trim();
    const titleClean = title.replace(/\s*\(.*?\)\s*/g, '').trim();
    const pageGuesses = isAlbum ? [
      titleClean + ' (' + artistFirst + ' album)',
      titleClean + ' (album)',
      titleClean
    ] : [
      titleClean + ' (' + artistFirst + ' song)',
      titleClean + ' (song)',
      titleClean
    ];

    let wikiHtml = null, wikiPageTitle = null;
    for (const guess of pageGuesses) {
      try {
        const url = `https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(guess)}&prop=text&format=json&origin=*&redirects=1`;
        const r = await fetch(url);
        const d = await r.json();
        if (d.parse && d.parse.text && d.parse.text['*']) {
          wikiHtml = d.parse.text['*'];
          wikiPageTitle = d.parse.title;
          break;
        }
      } catch(e) {}
    }

    // Fallback: search Wikipedia
    if (!wikiHtml) {
      const typeHint = isAlbum ? 'album' : 'song single';
      const searchQ = encodeURIComponent(`${titleClean} ${artistFirst} ${typeHint}`);
      const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${searchQ}&format=json&origin=*&srlimit=5`;
      const sr = await fetch(searchUrl);
      const sd = await sr.json();
      if (sd.query && sd.query.search && sd.query.search.length) {
        const tLow = titleClean.toLowerCase();
        const pick = sd.query.search.find(p => p.title.toLowerCase().includes(tLow)) || sd.query.search[0];
        try {
          const url = `https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(pick.title)}&prop=text&format=json&origin=*&redirects=1`;
          const r = await fetch(url);
          const d = await r.json();
          if (d.parse && d.parse.text) {
            wikiHtml = d.parse.text['*'];
            wikiPageTitle = d.parse.title;
          }
        } catch(e) {}
      }
    }

    if (!wikiHtml) { chartPeaksCache[key] = null; el.innerHTML = ''; return; }

    // Parse the HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(wikiHtml, 'text/html');

    // Find tables that look like chart performance tables
    const tables = doc.querySelectorAll('table.wikitable');
    const peaks = [];
    const seen = new Map();

    for (const table of tables) {
      const ths = [...table.querySelectorAll('tr:first-child th, thead th')];
      const headers = ths.map(th => th.textContent.trim().toLowerCase());

      // Find column indices
      let chartIdx = headers.findIndex(h => h.includes('chart'));
      let peakIdx = headers.findIndex(h => h.includes('peak') || h.includes('position'));

      if (chartIdx === -1 || peakIdx === -1) continue;

      const rows = table.querySelectorAll('tbody tr, tr');
      for (const row of rows) {
        // Wikipedia uses <th scope="row"> for chart names and <td> for peak positions
        // Get ALL cells (th + td) in order to handle both formats
        const allCells = [...row.querySelectorAll('th, td')];
        const tds = [...row.querySelectorAll('td')];
        const rowThs = [...row.querySelectorAll('th[scope="row"], th:not([colspan])')];

        if (tds.length === 0) continue; // skip pure header rows

        let chartCell, peakCell;

        // Case 1: Chart name in <th scope="row">, peak in <td>
        if (rowThs.length > 0 && tds.length >= 1) {
          chartCell = rowThs[0]; // first th in the row is the chart name
          peakCell = tds[tds.length - 1]; // last td is usually the peak (handles rowspan offsets)
        }
        // Case 2: Both chart and peak in <td> (old-style Wikipedia tables)
        else if (tds.length > Math.max(chartIdx, peakIdx)) {
          chartCell = tds[chartIdx];
          peakCell = tds[peakIdx];
        }
        // Case 3: Rowspan continuation ‚Äî only peak td present, no chart th
        else if (tds.length === 1 && rowThs.length === 0) {
          peakCell = tds[0];
        }
        else {
          continue;
        }

        const chartName = chartCell ? chartCell.textContent.trim().replace(/\[\d+\]/g, '').replace(/\[note\s*\d*\]/gi, '').trim() : '';
        const peakText = peakCell ? peakCell.textContent.trim().replace(/\[\d+\]/g, '').replace(/\[note\s*\d*\]/gi, '').trim() : '';
        const pos = parseInt(peakText);

        if (isNaN(pos) || pos < 1 || pos > 200) continue;

        // Check if this is a Billboard or US chart
        const cLow = chartName.toLowerCase();
        const isBillboard = cLow.includes('billboard') || cLow.includes('cashbox') || cLow.includes('cash box');
        const isUS = (cLow.startsWith('us') || cLow.includes('united states') || cLow.includes('(us)'));

        if (!isBillboard && !isUS) continue;

        const cleanName = cleanBillboardName(chartName);
        if (cleanName) {
          // Keep the best (lowest number) peak for each chart
          if (!seen.has(cleanName) || pos < seen.get(cleanName)) {
            seen.set(cleanName, pos);
            // Remove old entry if replacing
            const existing = peaks.findIndex(p => p.chart === cleanName);
            if (existing !== -1) peaks.splice(existing, 1);
            peaks.push({ chart: cleanName, peak: pos, raw: chartName });
          }
        }
      }
    }

    if (peaks.length === 0) { chartPeaksCache[key] = null; el.innerHTML = ''; return; }

    // Scan article prose for medley/double A-side mentions and attach to matching peaks
    const proseText = doc.body ? doc.body.textContent : '';
    const medleyPatterns = [
      /(?:medley|double\s+A-side)\s+with\s+["\u201C']([^"\u201D']+)["\u201D']/gi,
      /with\s+(?:\S+\s+){0,5}["\u201C']([^"\u201D']+)["\u201D']\s+as\s+a\s+(?:double\s+)?A-side/gi,
      /(?:backed|coupled|b\/w)\s+(?:with\s+)?["\u201C']([^"\u201D']+)["\u201D']/gi
    ];
    const medleyMatches = [];
    for (const re of medleyPatterns) {
      let mm;
      while ((mm = re.exec(proseText)) !== null) {
        medleyMatches.push({ song: mm[1].trim(), index: mm.index, full: mm[0], len: mm[0].length });
      }
    }
    for (const mm of medleyMatches) {
      // Find nearby chart reference ‚Äî look at surrounding 200 chars
      const ctx = proseText.substring(Math.max(0, mm.index - 100), mm.index + mm.len + 200).toLowerCase();
      // Try to match to a peak by chart keyword
      for (const p of peaks) {
        if (p.note) continue; // already annotated
        const chartWords = p.chart.toLowerCase().split(/\s+/);
        const keyWord = chartWords.find(w => w.length > 3 && w !== 'songs' && w !== 'chart');
        if (keyWord && ctx.includes(keyWord)) {
          p.note = mm.full.toLowerCase().includes('medley') ? `Medley with ${mm.song}` : `Double A-side with ${mm.song}`;
          break;
        }
      }
    }
    // Fallback: if medley mention found but no chart matched, try dance chart
    if (medleyMatches.length > 0 && !peaks.some(p => p.note)) {
      const dancePeak = peaks.find(p => p.chart.toLowerCase().includes('dance'));
      if (dancePeak) {
        const mm = medleyMatches[0];
        dancePeak.note = mm.full.toLowerCase().includes('medley') ? `Medley with ${mm.song}` : `Double A-side with ${mm.song}`;
      }
    }

    // Sort: #1s first, then by peak position
    peaks.sort((a, b) => a.peak - b.peak);

    const result = { peaks, wikiPage: wikiPageTitle, isAlbum: !!isAlbum };
    chartPeaksCache[key] = result;
    renderChartPeaks(el, result, isAlbum);

  } catch(e) {
    chartPeaksCache[key] = null;
    el.innerHTML = '';
  }
}

function cleanBillboardName(raw) {
  let n = raw
    .replace(/\[\d+\]/g, '')            // strip Wikipedia footnote refs like [3], [36]
    .replace(/\[note\s*\d*\]/gi, '')    // strip [note 1] style refs
    .replace(/\(Billboard\)/gi, '')
    .replace(/\(United States\)/gi, '')
    .replace(/^US\s+/i, '')
    .replace(/^U\.S\.\s+/i, '')
    .replace(/Billboard\s+/gi, '')
    .replace(/\s*\(\d{4}\)\s*/g, '')
    .replace(/\s*\(\d{4}[‚Äì-]\d{2,4}\)\s*/g, '')
    .trim();

  // Normalize known chart names
  const map = {
    'hot 100': 'Hot 100',
    'the hot 100': 'Hot 100',
    'hot r&b/hip-hop songs': 'Hot R&B Songs',
    'hot r&b songs': 'Hot R&B Songs',
    'hot r&b/hip-hop singles & tracks': 'Hot R&B Songs',
    'hot soul singles': 'Hot Soul Singles',
    'hot black singles': 'Hot Soul Singles',
    'best sellers in stores': 'Best Sellers in Stores',
    'hot country songs': 'Hot Country Songs',
    'hot country singles': 'Hot Country Songs',
    'hot country singles & tracks': 'Hot Country Songs',
    'adult contemporary': 'Adult Contemporary',
    'hot adult contemporary': 'Adult Contemporary',
    'hot adult contemporary tracks': 'Adult Contemporary',
    'adult top 40': 'Adult Top 40',
    'hot adult top 40 tracks': 'Adult Top 40',
    'dance club songs': 'Dance Club Songs',
    'hot dance club play': 'Dance Club Songs',
    'hot dance/disco club play': 'Dance Club Songs',
    'dance/mix show airplay': 'Dance/Mix Show Airplay',
    'hot dance/electronic songs': 'Hot Dance/Electronic Songs',
    'mainstream rock': 'Mainstream Rock',
    'mainstream rock tracks': 'Mainstream Rock',
    'hot mainstream rock tracks': 'Mainstream Rock',
    'album rock tracks': 'Mainstream Rock',
    'pop songs': 'Pop Songs',
    'top 40 mainstream': 'Pop Songs',
    'pop 100': 'Pop 100',
    'hot latin songs': 'Hot Latin Songs',
    'hot latin tracks': 'Hot Latin Songs',
    'rhythmic': 'Rhythmic',
    'rhythmic top 40': 'Rhythmic',
    'hot rap songs': 'Hot Rap Songs',
    'hot r&b/hip-hop airplay': 'Hot R&B Airplay',
    'hot 100 airplay': 'Hot 100 Airplay',
    'hot 100 recurrents': 'Hot 100 Recurrents',
    'bubbling under hot 100': 'Bubbling Under Hot 100',
    'bubbling under hot 100 singles': 'Bubbling Under Hot 100',
    'cash box top 100': 'Cash Box Top 100',
    'cash box': 'Cash Box Top 100',
    'cashbox': 'Cash Box Top 100',
    'billboard 200': 'Billboard 200',
    'the billboard 200': 'Billboard 200',
    'top r&b/hip-hop albums': 'Top R&B Albums',
    'top r&b albums': 'Top R&B Albums',
    'top black albums': 'Top R&B Albums',
    'top soul albums': 'Top R&B Albums',
    'r&b/hip-hop albums': 'Top R&B Albums',
    'top country albums': 'Top Country Albums',
    'country albums': 'Top Country Albums',
    'hot country albums': 'Top Country Albums',
    'top jazz albums': 'Top Jazz Albums',
    'jazz albums': 'Top Jazz Albums',
    'top contemporary jazz albums': 'Top Contemporary Jazz Albums',
    'top latin albums': 'Top Latin Albums',
    'latin albums': 'Top Latin Albums',
    'top gospel albums': 'Top Gospel Albums',
    'top christian albums': 'Top Christian Albums',
    'top classical albums': 'Top Classical Albums',
    'top dance/electronic albums': 'Top Dance/Electronic Albums',
    'dance/electronic albums': 'Top Dance/Electronic Albums',
    'top rock albums': 'Top Rock Albums',
    'rock albums': 'Top Rock Albums',
    'top rap albums': 'Top Rap Albums',
    'rap albums': 'Top Rap Albums',
    'top alternative albums': 'Top Alternative Albums',
    'independent albums': 'Independent Albums',
    'top independent albums': 'Independent Albums',
    'indie albums': 'Independent Albums',
    'top soundtracks': 'Top Soundtracks',
    'soundtrack albums': 'Top Soundtracks',
    'top catalog albums': 'Top Catalog Albums',
    'catalog albums': 'Top Catalog Albums',
    'top internet albums': 'Top Internet Albums',
    'top tastemaker albums': 'Top Tastemaker Albums',
    'folk albums': 'Top Americana/Folk Albums',
    'americana/folk albums': 'Top Americana/Folk Albums',
    'heatseekers albums': 'Heatseekers Albums',
    'top heatseekers': 'Heatseekers Albums',
  };

  const nLow = n.toLowerCase();
  if (map[nLow]) return map[nLow];

  // Return cleaned version if not in map
  return n || null;
}

function renderChartPeaks(el, data, isAlbum) {
  if (!data || !data.peaks || data.peaks.length === 0) { el.innerHTML = ''; if (!isAlbum) updateSongEnrichment('chartPeaks', []); return; }

  const { peaks, wikiPage } = data;

  // Filter out the primary chart ‚Äî already shown in the header
  // For songs: exclude Hot 100 and variants
  // For albums: exclude Billboard 200 and variants
  const excludeSet = isAlbum
    ? new Set(['Billboard 200', '200', 'The 200', 'United States', 'US', 'U.S.', 'US Billboard 200', 'Billboard 200 Albums'])
    : new Set(['Hot 100', 'The Hot 100', 'Bubbling Under Hot 100', 'Hot 100 Airplay', 'Hot 100 Recurrents', 'United States', 'US', 'U.S.', 'US Billboard Hot 100', 'Billboard Hot 100']);
  const excludeSubstring = isAlbum
    ? ['billboard 200', 'top 200']
    : ['hot 100', 'bubbling under'];
  const filtered = peaks.filter(p => {
    if (excludeSet.has(p.chart)) return false;
    const low = p.chart.toLowerCase();
    if (excludeSubstring.some(s => low.includes(s))) return false;
    return true;
  });
  if (filtered.length === 0) { el.innerHTML = ''; if (!isAlbum) updateSongEnrichment('chartPeaks', []); return; }

  const no1Count = filtered.filter(p => p.peak === 1).length;
  const subtitle = no1Count > 0
    ? `${filtered.length} chart${filtered.length !== 1 ? 's' : ''} ¬∑ ${no1Count} #1${no1Count !== 1 ? 's' : ''}`
    : `${filtered.length} chart${filtered.length !== 1 ? 's' : ''}`;

  let h = `<div class="chart-peaks-section">
    <div class="chart-peaks-title">üìä Other Billboard Chart Peaks<span class="cp-sub">${subtitle}</span></div>
    <div class="chart-peaks-grid">`;

  for (const p of filtered) {
    const cls = p.peak === 1 ? 'peak-1' : p.peak <= 5 ? 'peak-top5' : p.peak <= 10 ? 'peak-top10' : p.peak <= 20 ? 'peak-top20' : 'peak-deep';
    const cardCls = p.peak === 1 ? ' peak-card-1' : '';
    h += `<div class="chart-peak-card${cardCls}">
      <div class="chart-peak-pos ${cls}">#${p.peak}</div>
      <div class="chart-peak-name"><span class="cp-main">${p.chart}</span>${p.note ? `<span class="cp-note">${p.note}</span>` : ''}</div>
    </div>`;
  }

  h += '</div>';
  if (wikiPage) {
    h += `<div class="chart-peaks-source">Source: <a href="https://en.wikipedia.org/wiki/${encodeURIComponent(wikiPage)}" target="_blank" rel="noopener">Wikipedia ‚Äî ${wikiPage}</a></div>`;
  }
  h += '</div>';
  el.innerHTML = h;

  // Feed filtered peaks into song enrichment narrative
  if (!isAlbum) updateSongEnrichment('chartPeaks', filtered);
}

// ‚îÄ‚îÄ‚îÄ ALBUM SINGLES (from Hot 100 cross-reference) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function findAlbumSingles(albumTitle, artist, albumWeeks, elementId, trackNames) {
  const el = document.getElementById(elementId);
  if (!el) return;

  // Need track names to filter accurately
  if (!trackNames || trackNames.length === 0) { el.innerHTML = ''; return; }

  // Need Hot 100 data loaded
  const h100Weeks = Object.keys(chartCache).length;
  if (h100Weeks === 0) {
    if (albumWeeks.length) {
      const albumYr = +albumWeeks[0].date.substring(0, 4);
      el.innerHTML = `<div class="album-singles-section"><div class="album-singles-title">üéµ Hot 100 Singles</div><div style="font-size:12px;color:var(--text-faint)">Load the ${albumYr}s Hot 100 data to see charting singles from this album.</div></div>`;
    } else {
      el.innerHTML = '';
    }
    return;
  }

  // Get album's date range
  if (!albumWeeks.length) { el.innerHTML = ''; return; }
  const albumDates = albumWeeks.map(w => w.date).sort();
  const firstDate = albumDates[0];

  // Parse date helper
  const toMs = d => new Date(d + 'T00:00:00Z').getTime();
  const firstMs = toMs(firstDate);

  // Window: 6 months before album debut to 18 months after
  const windowBefore = 6 * 30 * 24 * 60 * 60 * 1000;
  const windowAfter = 18 * 30 * 24 * 60 * 60 * 1000;
  const startMs = firstMs - windowBefore;
  const endMs = firstMs + windowAfter;

  // Normalize for matching
  const norm = s => stripAccents(s).toLowerCase().replace(/[^a-z0-9]/g, '');
  const stripParens = s => s.replace(/\s*\(.*?\)\s*/g, '').replace(/\s*\[.*?\]\s*/g, '').trim();

  // Build set of normalized track names for filtering
  const trackSet = new Set();
  for (const t of trackNames) {
    trackSet.add(norm(t));
    trackSet.add(norm(stripParens(t)));
  }

  // Scan Hot 100 cache for songs by this artist in the window
  const singles = new Map();

  for (const [date, entries] of Object.entries(chartCache)) {
    if (!Array.isArray(entries)) continue;
    const dateMs = toMs(date);
    if (dateMs < startMs || dateMs > endMs) continue;

    for (const e of entries) {
      if (!e || !e.artist || !e.title) continue;
      if (!artistMatches(e.artist, artist)) continue;

      // Filter against track list
      const titleNorm = norm(e.title);
      const titleStripped = norm(stripParens(e.title));
      let matched = false;
      for (const tn of trackSet) {
        if (tn === titleNorm || tn === titleStripped ||
            titleNorm.includes(tn) || tn.includes(titleNorm) ||
            titleStripped.includes(tn) || tn.includes(titleStripped)) {
          matched = true;
          break;
        }
      }
      if (!matched) continue;

      const key = e.title.toLowerCase();
      if (!singles.has(key)) {
        singles.set(key, {
          title: e.title,
          artist: e.artist,
          peak: e.rank,
          weeks: 1,
          firstDate: date,
          lastDate: date
        });
      } else {
        const s = singles.get(key);
        s.weeks++;
        if (e.rank < s.peak) s.peak = e.rank;
        if (date < s.firstDate) s.firstDate = date;
        if (date > s.lastDate) s.lastDate = date;
      }
    }
  }

  if (singles.size === 0) {
    // Check if we even have Hot 100 data for this era
    const albumYr = +firstDate.substring(0, 4);
    const hasEra = Object.keys(chartCache).some(d => Math.abs((+d.substring(0, 4)) - albumYr) <= 1);
    if (!hasEra) {
      el.innerHTML = `<div class="album-singles-section"><div class="album-singles-title">üéµ Hot 100 Singles</div><div style="font-size:12px;color:var(--text-faint)">Load the ${albumYr}s Hot 100 data to see charting singles from this album.</div></div>`;
    } else {
      el.innerHTML = '';
    }
    return;
  }

  // Sort by peak position (best first), then by weeks (most first)
  const sorted = [...singles.values()].sort((a, b) => a.peak - b.peak || b.weeks - a.weeks);

  const no1Count = sorted.filter(s => s.peak === 1).length;
  const subtitle = no1Count > 0
    ? `${sorted.length} single${sorted.length !== 1 ? 's' : ''} ¬∑ ${no1Count} #1${no1Count !== 1 ? 's' : ''}`
    : `${sorted.length} single${sorted.length !== 1 ? 's' : ''}`;

  let h = `<div class="album-singles-section">
    <div class="album-singles-title">üéµ Hot 100 Singles<span class="as-sub">${subtitle}</span></div>`;

  for (const s of sorted) {
    const peakCls = s.peak === 1 ? 'as-peak-1' : s.peak <= 5 ? 'as-peak-top5' : s.peak <= 10 ? 'as-peak-top10' : s.peak <= 20 ? 'as-peak-top20' : 'as-peak-deep';
    const cardCls = s.peak === 1 ? ' as-no1' : '';
    const badge = s.peak === 1 ? '<span class="as-badge as-badge-1">üëë #1</span>' : s.peak <= 10 ? '<span class="as-badge">TOP 10</span>' : s.peak <= 40 ? '<span class="as-badge">TOP 40</span>' : '';
    h += `<div class="album-single-card${cardCls}" onclick="viewSingleFromAlbum('${esc(s.title)}','${esc(s.artist)}','${esc(albumTitle)}','${esc(artist)}')">
      <div class="as-peak ${peakCls}">#${s.peak}</div>
      <div class="as-info">
        <div class="as-title">${s.title}</div>
        <div class="as-meta"><span>${s.weeks} wk${s.weeks !== 1 ? 's' : ''} on chart</span><span>Debuted ${fmtDate(s.firstDate)}</span></div>
      </div>
      ${badge}
    </div>`;
  }

  h += '</div>';
  el.innerHTML = h;
}

function viewSingleFromAlbum(title, artist, albumTitle, albumArtist) {
  // Store album context for the song detail page
  if (albumTitle) {
    _pendingAlbumContext = { albumTitle, albumArtist: albumArtist || artist };
  }
  // Switch to Hot 100 to show the single's chart run
  const wasB200 = chartType === 'billboard200';
  if (wasB200) {
    chartType = 'hot100';
    document.querySelectorAll('.chart-type-btn').forEach(b => {
      b.classList.toggle('active', b.textContent.includes('100'));
    });
  }
  showSong(title, artist);
}

// ‚îÄ‚îÄ‚îÄ ALBUM TRACKS (iTunes) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const albumTracksCache = {};

async function fetchAlbumTracks(title, artist, albumYear, elementId, albumWeeks) {
  const el = document.getElementById(elementId);
  if (!el) return;
  const key = title + '|' + artist + '|' + albumYear;
  if (albumTracksCache[key]) {
    renderAlbumTracks(el, albumTracksCache[key]);
    // Trigger singles with known track names
    const trackNames = albumTracksCache[key].tracks.map(t => t.name).filter(Boolean);
    if (albumWeeks) findAlbumSingles(title, artist, albumWeeks, 'albumSingles', trackNames);
    return;
  }

  el.innerHTML = `<div class="tracklist-section loading"><div class="tracklist-title">Track List</div><div style="font-size:12px;color:var(--text-faint)">Looking up tracks...</div></div>`;

  try {
    // Build title variants: full title, then subtitle parts after dash/colon
    const titleVariants = [title];
    for (const sep of [' ‚Äì ', ' - ', ': ']) {
      if (title.includes(sep)) {
        const parts = title.split(sep);
        titleVariants.push(parts[parts.length - 1].trim()); // subtitle (e.g. "Chic's Greatest Hits")
        titleVariants.push(parts[0].trim()); // prefix (e.g. "Les Plus Grands Succes De Chic")
      }
    }
    // Also try slash splits
    if (title.includes('/')) titleVariants.push(title.split('/')[0].trim());

    const artistLow = stripAccents(artist).toLowerCase().replace(/[^a-z0-9]/g, '');
    let bestMatch = null, bestScore = -1;

    for (const tryTitle of titleVariants) {
      const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(tryTitle + ' ' + artist)}&entity=album&country=US&limit=15`;
      const r1 = await fetch(searchUrl);
      if (!r1.ok) continue;
      const searchData = await r1.json();
      if (!searchData.results || !searchData.results.length) continue;

      const sNorm = s => stripAccents(s).toLowerCase().replace(/[^a-z0-9]/g, '');
      const titleLow = sNorm(tryTitle);
      const fullTitleLow = sNorm(title);

      for (const r of searchData.results) {
        const rTitle = sNorm(r.collectionName || '');
        const rArtist = sNorm(r.artistName || '');
        const rYear = r.releaseDate ? +r.releaseDate.substring(0, 4) : 0;
        let score = 0;

        // Title match ‚Äî check against both the variant and the full original title
        if (rTitle === titleLow || rTitle === fullTitleLow) score += 10;
        else if (rTitle.includes(titleLow) || titleLow.includes(rTitle)) score += 5;
        else if (rTitle.includes(fullTitleLow) || fullTitleLow.includes(rTitle)) score += 5;
        else continue;

        // Artist match
        if (rArtist === artistLow) score += 5;
        else if (rArtist.includes(artistLow) || artistLow.includes(rArtist)) score += 3;

        // Year match
        if (albumYear && rYear) {
          if (rYear === albumYear) score += 8;
          else if (rYear === albumYear - 1) score += 6;
          else if (Math.abs(rYear - albumYear) <= 2) score += 3;
          else score -= 2;
        }

        if (score > bestScore) { bestScore = score; bestMatch = r; }
      }
      // Stop if we found a solid match
      if (bestMatch && bestScore >= 8) break;
    }

    if (!bestMatch) throw 'no-match';

    const collectionId = bestMatch.collectionId;
    if (!collectionId) throw 'no-id';

    // Lookup album tracks
    const lookupUrl = `https://itunes.apple.com/lookup?id=${collectionId}&entity=song&limit=200`;
    const r2 = await fetch(lookupUrl);
    if (!r2.ok) throw new Error('iTunes lookup: ' + r2.status);
    const lookupData = await r2.json();

    if (!lookupData.results || lookupData.results.length < 2) throw 'no-tracks';

    // First result is the collection, rest are tracks
    const albumInfo = lookupData.results[0];
    const tracks = lookupData.results.slice(1).filter(t => t.wrapperType === 'track');

    const data = {
      albumName: cleanAlbumTitle(albumInfo.collectionName || title),
      artistName: albumInfo.artistName || artist,
      releaseDate: albumInfo.releaseDate || '',
      genre: albumInfo.primaryGenreName || '',
      trackCount: albumInfo.trackCount || tracks.length,
      label: cleanCopyright(albumInfo.copyright || ''),
      tracks: tracks.map(t => ({
        num: t.trackNumber || 0,
        disc: t.discNumber || 1,
        name: t.trackName || '',
        duration: t.trackTimeMillis || 0,
        artist: t.artistName || ''
      }))
    };

    albumTracksCache[key] = data;
    renderAlbumTracks(el, data);
    // Trigger singles filtered by track list
    const trackNames = data.tracks.map(t => t.name).filter(Boolean);
    if (albumWeeks) findAlbumSingles(title, artist, albumWeeks, 'albumSingles', trackNames);
  } catch(e) {
    if (typeof e !== 'string') console.error('Album tracks error:', e);
    el.innerHTML = '';
    // No track list = can't filter singles accurately, skip
  }
}

function renderAlbumTracks(el, data) {
  if (!data.tracks || data.tracks.length === 0) { el.innerHTML = ''; return; }

  const fmtMs = (ms) => {
    if (!ms) return '';
    const s = Math.floor(ms / 1000);
    return Math.floor(s / 60) + ':' + String(s % 60).padStart(2, '0');
  };

  const totalMs = data.tracks.reduce((s, t) => s + (t.duration || 0), 0);
  const maxDisc = Math.max(...data.tracks.map(t => t.disc || 1));

  let h = `<div class="tracklist-section">`;
  h += `<div class="tracklist-title">Track List <span class="track-count">${data.tracks.length} tracks${totalMs ? ' ¬∑ ' + fmtMs(totalMs) : ''}</span></div>`;

  // Album meta
  const metaParts = [];
  if (data.releaseDate) {
    const yr = data.releaseDate.substring(0, 4);
    const fullDate = new Date(data.releaseDate);
    const dateStr = !isNaN(fullDate) ? fullDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : yr;
    metaParts.push(`<span>Released</span>${dateStr}`);
  }
  if (data.genre) metaParts.push(`<span>Genre</span>${data.genre}`);
  if (data.label && data.label.length > 0 && data.label.length < 80) {
    metaParts.push(`<span>Label</span>${data.label}`);
  }
  if (metaParts.length) h += `<div class="album-meta-row">${metaParts.join('')}</div>`;

  // Tracks, grouped by disc if multi-disc
  if (maxDisc > 1) {
    for (let d = 1; d <= maxDisc; d++) {
      const discTracks = data.tracks.filter(t => t.disc === d);
      if (discTracks.length === 0) continue;
      h += `<div class="track-disc-label">Disc ${d}</div>`;
      discTracks.forEach(t => {
        h += `<div class="track-item"><div class="track-num">${t.num}</div><div class="track-name">${t.name}</div><div class="track-duration">${fmtMs(t.duration)}</div></div>`;
      });
    }
  } else {
    data.tracks.forEach(t => {
      h += `<div class="track-item"><div class="track-num">${t.num}</div><div class="track-name">${t.name}</div><div class="track-duration">${fmtMs(t.duration)}</div></div>`;
    });
  }

  h += `</div>`;
  el.innerHTML = h;
}

// ‚îÄ‚îÄ‚îÄ ALBUM CREDITS (MusicBrainz) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const albumCreditsCache = {};

async function fetchAlbumCredits(title, artist, albumYear, elementId) {
  const el = document.getElementById(elementId);
  if (!el) return;
  const key = title + '|' + artist + '|' + albumYear;
  if (albumCreditsCache[key]) { renderAlbumCredits(el, albumCreditsCache[key]); return; }

  el.innerHTML = `<div class="credits-section loading"><div class="credits-title">Credits</div><div style="font-size:12px;color:var(--text-faint)">Looking up producers & credits...</div></div>`;

  try {
    let producers = [], engineers = [], mixers = [], writers = [], arrangers = [], performers = [];
    let labelNames = [];

    // Step 1: Search for the release (same query format as working song credits)
    const q = encodeURIComponent(title) + '%20AND%20artist:' + encodeURIComponent(artist);
    const r1 = await fetch('https://musicbrainz.org/ws/2/release?query=' + q + '&fmt=json&limit=10');
    if (!r1.ok) throw new Error('MB search: ' + r1.status);
    const search = await r1.json();

    if (!search.releases || search.releases.length === 0) { el.innerHTML = ''; return; }

    // Find best matching release using title + year
    const titleLow = title.toLowerCase();
    let bestRelease = null, bestScore = -1;
    for (const rel of search.releases) {
      const rTitle = (rel.title || '').toLowerCase();
      const rDate = rel.date || '';
      const rYear = rDate ? +rDate.substring(0, 4) : 0;
      let score = 0;
      if (rTitle === titleLow) score += 10;
      else if (rTitle.includes(titleLow) || titleLow.includes(rTitle)) score += 5;
      else continue;
      if (albumYear && rYear) {
        if (rYear === albumYear || rYear === albumYear - 1) score += 8;
        else if (Math.abs(rYear - albumYear) <= 2) score += 4;
      }
      if (rel.status === 'Official') score += 2;
      if (rel['track-count'] && rel['track-count'] > 5) score += 1;
      if (score > bestScore) { bestScore = score; bestRelease = rel; }
    }

    if (!bestRelease) bestRelease = search.releases[0];

    // Step 2: Fetch release with recording-level-rels (this is where credits live!)
    // MusicBrainz stores producer/engineer/mixer credits on individual recordings,
    // not on the release itself. recording-level-rels pulls all track-level credits.
    await sleep(1100);
    const r2 = await fetch(`https://musicbrainz.org/ws/2/release/${bestRelease.id}?inc=recordings+artist-rels+recording-level-rels+label-rels&fmt=json`);
    if (!r2.ok) throw new Error('MB release: ' + r2.status);
    const relData = await r2.json();

    // Helper to collect credits from a relations array
    function collectCredits(rels) {
      if (!rels) return;
      for (const rel of rels) {
        if (!rel.artist) continue;
        const t = (rel.type || '').toLowerCase();
        const name = rel.artist.name;
        if (!name) continue;
        if (t === 'producer' || t === 'co-producer') { if (!producers.includes(name)) producers.push(name); }
        else if (t === 'engineer' || t === 'recording' || t === 'balance' || t === 'audio') { if (!engineers.includes(name)) engineers.push(name); }
        else if (t === 'mix' || t === 'mixer' || t === 'remixer') { if (!mixers.includes(name)) mixers.push(name); }
        else if (t === 'mastering') { if (!mixers.includes(name + ' (mastering)')) mixers.push(name + ' (mastering)'); }
        else if (t === 'writer' || t === 'composer' || t === 'lyricist') { if (!writers.includes(name)) writers.push(name); }
        else if (t.includes('arranger') || t.includes('orchestrat')) { if (!arrangers.includes(name)) arrangers.push(name); }
        else if (t === 'instrument' || t === 'vocal' || t === 'performer' || t === 'performing orchestra' || t === 'conductor') {
          const attr = rel.attributes && rel.attributes.length ? rel.attributes.join(', ') : t;
          if (!performers.find(p => p.name === name)) performers.push({ name, role: attr });
        }
      }
    }

    // Collect release-level credits
    collectCredits(relData.relations);

    // Collect recording-level credits (the main source of producer/engineer data)
    if (relData.media) {
      for (const medium of relData.media) {
        if (medium.tracks) {
          for (const track of medium.tracks) {
            if (track.recording && track.recording.relations) {
              collectCredits(track.recording.relations);
            }
          }
        }
      }
    }

    // Extract label info
    if (relData['label-info'] && relData['label-info'].length > 0) {
      labelNames = relData['label-info'].map(li => li.label ? li.label.name : '').filter(Boolean);
    }

    const credits = {
      producers, engineers, mixers, writers, arrangers, performers,
      label: labelNames.length ? [...new Set(labelNames)].join(' / ') : '',
      others: []
    };
    albumCreditsCache[key] = credits;
    renderAlbumCredits(el, credits);
  } catch(e) {
    console.error('Album credits error:', e);
    el.innerHTML = '';
  }
}

function renderAlbumCredits(el, credits) {
  const hasAny = credits.producers.length || credits.engineers.length || credits.mixers.length ||
    credits.writers.length || credits.arrangers.length || (credits.performers && credits.performers.length) || credits.label;
  if (!hasAny) { el.innerHTML = ''; return; }

  let h = `<div class="credits-section"><div class="credits-title">Credits</div>`;
  if (credits.producers.length) h += `<div class="credits-row"><div class="credits-label">Produced by</div><div class="credits-names">${credits.producers.map(n => `<span>${n}</span>`).join(', ')}</div></div>`;
  if (credits.writers.length) h += `<div class="credits-row"><div class="credits-label">Written by</div><div class="credits-names">${credits.writers.map(n => `<span>${n}</span>`).join(', ')}</div></div>`;
  if (credits.arrangers.length) h += `<div class="credits-row"><div class="credits-label">Arranged by</div><div class="credits-names">${credits.arrangers.map(n => `<span>${n}</span>`).join(', ')}</div></div>`;
  if (credits.engineers.length) h += `<div class="credits-row"><div class="credits-label">Engineered by</div><div class="credits-names">${credits.engineers.map(n => `<span>${n}</span>`).join(', ')}</div></div>`;
  if (credits.mixers.length) h += `<div class="credits-row"><div class="credits-label">Mixed / Mastered</div><div class="credits-names">${credits.mixers.map(n => `<span>${n}</span>`).join(', ')}</div></div>`;
  if (credits.performers && credits.performers.length) {
    h += `<div class="credits-row"><div class="credits-label">Musicians</div><div class="credits-names">${credits.performers.map(p => `<span>${p.name}</span> <span style="color:#555;font-size:11px">(${p.role})</span>`).join(', ')}</div></div>`;
  }
  if (credits.label) h += `<div class="credits-row"><div class="credits-label">Label</div><div class="credits-names"><span>${credits.label}</span></div></div>`;
  h += `</div>`;
  el.innerHTML = h;
}


// ‚îÄ‚îÄ‚îÄ ITUNES IMAGES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const imgCache = {};
// Global compilation detection regex ‚Äî catches greatest hits, box sets, decade compilations, etc.
const COMPILATION_RE = /greatest|best\s*of|#1|number\s*one|collection|essential|anthology|legend|definitive|gold|platinum|ultimate|complete|20th\s*century|hits!|super\s*hits|very\s*best|all[\s-]*time|this\s*is\s*(the\s*)?|now\s*that'?s|classic\s*(hits|soul|rock|disco|funk|pop|r&b)|jukebox|throwback|remastered.*hits|original\s*hits|big\s*hits|smash\s*hits|mega\s*hits|hot\s*hits|pure\s*(disco|soul|funk|80s|70s|60s)|back\s*to\s*the\s*\d|\bdecade\b|\bchronicle\b|\bicon\b|\bflashback\b|\brarities\b|\btimeless\b|\bforever\b|\bthe\s+singles\b|\bthe\s+hits\b|\bhit\s*singles\b|\bsingles\s*collection\b|\b\d+\s*greatest\b/i;
const stripAccents = s => s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
const NORM_FN = s => stripAccents(s).toLowerCase().replace(/[^a-z0-9]/g, ' ').replace(/\s+/g,' ').trim();
// Shared artwork cache: populated by artist page, reused by song detail page
// Key: 'title|||artist' ‚Üí { thumb: url, full: url }
const hitArtData = {};
const creditsCache = {};

async function fetchSongCredits(title, artist, elementId) {
  const key = title + '|' + artist;
  const el = document.getElementById(elementId);
  if (!el) return;

  if (creditsCache[key]) { renderCredits(el, creditsCache[key]); updateSongEnrichment('credits', creditsCache[key]); return; }

  el.innerHTML = `<div class="credits-section loading"><div class="credits-title">Credits</div><div style="font-size:12px;color:var(--text-faint)">Looking up writers & producers...</div></div>`;

  try {
    // Step 1: Search for the recording ‚Äî try artist-specific, then broader
    let search = null;
    const queries = [
      encodeURIComponent(title) + '%20AND%20artist:' + encodeURIComponent(artist),
      encodeURIComponent(title + ' ' + artist)
    ];

    for (const q of queries) {
      const searchUrl = 'https://musicbrainz.org/ws/2/recording?query=' + q + '&fmt=json&limit=5';
      const r1 = await fetch(searchUrl);
      if (!r1.ok) continue;
      search = await r1.json();
      if (search.recordings && search.recordings.length > 0) break;
    }

    if (!search || !search.recordings || search.recordings.length === 0) {
      el.innerHTML = '';
      updateSongEnrichment('credits', { writers: [], producers: [] });
      return;
    }

    // Find best match ‚Äî prefer exact title + artist match
    const titleLow = title.toLowerCase();
    const artistLow = artist.toLowerCase();
    const recs = search.recordings;

    // Priority 1: Exact title + artist contains match
    const rec = recs.find(r =>
      r.title && r.title.toLowerCase() === titleLow &&
      r['artist-credit'] && r['artist-credit'].some(ac => ac.artist && ac.artist.name.toLowerCase().includes(artistLow.substring(0,6)))
    ) || recs.find(r =>
      r.title && r.title.toLowerCase() === titleLow
    ) || recs.find(r =>
      r.title && r.title.toLowerCase().includes(titleLow.substring(0, Math.min(10, titleLow.length)))
    ) || recs[0];

    // Step 2: Get recording with BOTH artist-rels and work-rels
    await sleep(1100);
    const recUrl = `https://musicbrainz.org/ws/2/recording/${rec.id}?inc=artist-rels+work-rels&fmt=json`;
    const r2 = await fetch(recUrl);
    if (!r2.ok) throw new Error('rec ' + r2.status);
    const recData = await r2.json();

    let writers = [], producers = [], arrangers = [], musicians = [];

    // Extract producers, arrangers, musicians from recording relationships
    if (recData.relations) {
      for (const rel of recData.relations) {
        if (!rel.artist) continue;
        const name = rel.artist.name;
        const t = (rel.type || '').toLowerCase();
        if (t === 'producer' || t === 'co-producer') producers.push(name);
        else if (t.includes('arranger')) arrangers.push(name);
        else if (t === 'performer' || t === 'instrument' || t === 'vocal') {
          const attr = (rel.attributes || []).join(', ');
          musicians.push(attr ? `${name} (${attr})` : name);
        }
        // Some recordings have writer rels directly
        else if (t === 'writer' || t === 'composer' || t === 'lyricist') writers.push(name);
      }
    }

    // Step 3: Get writers from linked works
    // work-rels on a recording gives us relations of type "performance" pointing to works
    const workIds = [];
    if (recData.relations) {
      for (const rel of recData.relations) {
        if (rel.type === 'performance' && rel.work && rel.work.id) {
          workIds.push(rel.work.id);
        }
      }
    }

    // Fetch each work for writer credits
    for (const workId of workIds.slice(0, 2)) {
      await sleep(1100);
      const workUrl = `https://musicbrainz.org/ws/2/work/${workId}?inc=artist-rels&fmt=json`;
      const r3 = await fetch(workUrl);
      if (!r3.ok) continue;
      const workData = await r3.json();

      if (workData.relations) {
        for (const rel of workData.relations) {
          if (!rel.artist) continue;
          const name = rel.artist.name;
          const t = (rel.type || '').toLowerCase();
          if (t === 'writer' || t === 'composer' || t === 'lyricist' || t === 'songwriter') {
            writers.push(name);
          }
        }
      }
    }

    writers = [...new Set(writers)];
    producers = [...new Set(producers)];
    arrangers = [...new Set(arrangers)];
    musicians = [...new Set(musicians)];

    const credits = { writers, producers, arrangers, musicians };
    creditsCache[key] = credits;

    if (writers.length === 0 && producers.length === 0 && arrangers.length === 0 && musicians.length === 0) {
      el.innerHTML = '';
      updateSongEnrichment('credits', { writers: [], producers: [] });
      return;
    }
    renderCredits(el, credits);
    updateSongEnrichment('credits', credits);

  } catch(e) {
    el.innerHTML = '';
    updateSongEnrichment('credits', { writers: [], producers: [] });
  }
}

function renderCredits(el, credits) {
  const { writers, producers, arrangers, musicians } = credits;
  if ((!writers || writers.length === 0) && (!producers || producers.length === 0) && (!arrangers || arrangers.length === 0) && (!musicians || musicians.length === 0)) {
    el.innerHTML = '';
    return;
  }

  const nameLink = n => `<span class="credit-name" onclick="goToArtist('${esc(n)}')">${n}</span>`;

  let h = `<div class="credits-section"><div class="credits-title">Credits</div>`;
  if (writers && writers.length > 0) {
    h += `<div class="credits-row"><div class="credits-label">Written by</div><div class="credits-names">${writers.map(nameLink).join(', ')}</div></div>`;
  }
  if (producers && producers.length > 0) {
    h += `<div class="credits-row"><div class="credits-label">Produced by</div><div class="credits-names">${producers.map(nameLink).join(', ')}</div></div>`;
  }
  if (arrangers && arrangers.length > 0) {
    h += `<div class="credits-row"><div class="credits-label">Arranged by</div><div class="credits-names">${arrangers.map(nameLink).join(', ')}</div></div>`;
  }
  if (musicians && musicians.length > 0) {
    h += `<div class="credits-row"><div class="credits-label">Musicians</div><div class="credits-names">${musicians.map(m => {
      const match = m.match(/^(.+?)\s*\((.+)\)$/);
      if (match) return nameLink(match[1]) + ` <span class="credit-attr">(${match[2]})</span>`;
      return nameLink(m);
    }).join(', ')}</div></div>`;
  }
  h += `<div style="font-size:10px;color:#333;margin-top:8px">via MusicBrainz</div></div>`;
  el.innerHTML = h;
}

async function fetchArtistImage(name, elementId) {
  const key = 'artist:' + name;
  if (imgCache[key]) { applyImage(elementId, imgCache[key]); return; }
  try {
    // Search for songs by this artist ‚Äî album artwork from their biggest original LP
    const r = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(name)}&entity=song&country=US&limit=10`);
    const data = await r.json();
    if (data.results && data.results.length > 0) {
      const pick = pickOriginalAlbumArt(data.results, name, false, COMPILATION_RE, NORM_FN, null);
      if (pick && pick.artworkUrl100) {
        const url = pick.artworkUrl100.replace('100x100', '600x600');
        imgCache[key] = url;
        applyImage(elementId, url);
      }
    }
  } catch(e) {}
}

async function fetchSongImage(title, artist, elementId, chartYear) {
  const hitKey = title + '|||' + artist;
  if (hitArtData[hitKey]) {
    applySongImage(elementId, hitArtData[hitKey].full || hitArtData[hitKey].thumb);
    return;
  }

  const key = 'song:' + title + '|' + artist;
  if (imgCache[key]) { applySongImage(elementId, imgCache[key]); return; }

  const isAlbum = chartType === 'billboard200';

  try {
    const entity = isAlbum ? 'entity=album' : 'entity=song';
    // Try full title first, then first part of slash title if needed
    const titleVariants = [title];
    if (title.includes('/')) titleVariants.push(title.split('/')[0].trim());

    let pick = null;
    for (const tryTitle of titleVariants) {
      const r = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(artist + ' ' + tryTitle)}&${entity}&country=US&limit=15`);
      const data = await r.json();
      if (!data.results || !data.results.length) continue;

      let pool = data.results;
      if (!isAlbum) {
        const titleLow = tryTitle.toLowerCase().substring(0, 10);
        const artistLow = artist.toLowerCase().substring(0, 6);
        const matched = data.results.filter(r =>
          r.trackName && r.artistName &&
          r.trackName.toLowerCase().includes(titleLow) &&
          r.artistName.toLowerCase().includes(artistLow)
        );
        if (matched.length) pool = matched;
      }

      pick = pickOriginalAlbumArt(pool, tryTitle, isAlbum, COMPILATION_RE, NORM_FN, chartYear);
      if (pick && pick.artworkUrl100) break;
    }

    if (pick && pick.artworkUrl100) {
      const url = pick.artworkUrl100.replace('100x100', '600x600');
      imgCache[key] = url;
      hitArtData[hitKey] = { thumb: pick.artworkUrl100, full: url };
      applySongImage(elementId, url);
    }
  } catch(e) {}
}

function applySongImage(elementId, url) {
  const el = document.getElementById(elementId);
  if (!el) return;
  const img = new Image();
  img.onload = () => {
    el.innerHTML = `<img src="${url}" alt="">`;
    el.classList.add('loaded');
  };
  img.onerror = () => {};
  img.src = url;
}

function applyImage(elementId, url) {
  const el = document.getElementById(elementId);
  if (!el) return;
  const img = new Image();
  img.onload = () => { el.innerHTML = `<img src="${url}" alt="">`; el.classList.add('loaded'); };
  img.onerror = () => {}; // silently fail
  img.src = url;
}

// ‚îÄ‚îÄ‚îÄ NARRATIVES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function songNarrative(title, artist, weeks, peakPos, maxWks, isAlbum) {
  if (!weeks || weeks.length < 2) return '';
  const first = weeks[0], last = weeks[weeks.length - 1];
  const debut = first.rank;
  const debutDate = fmtDate(first.date);
  const chartName = isAlbum ? 'Billboard 200' : 'Hot 100';

  // Weeks to peak
  const peakIdx = weeks.findIndex(w => w.rank === peakPos);
  const weeksToPeak = peakIdx >= 0 ? peakIdx + 1 : '?';

  // Weeks at peak
  const weeksAtPeak = weeks.filter(w => w.rank === peakPos).length;

  // Biggest single-week jump
  let biggestJump = 0, jumpWeek = null;
  for (let i = 1; i < weeks.length; i++) {
    const diff = (weeks[i-1].rank || 0) - (weeks[i].rank || 0);
    if (diff > biggestJump) { biggestJump = diff; jumpWeek = i; }
  }

  // Build narrative
  let n = `<strong>"${title}"</strong> by <span class="gld">${artist}</span> `;

  // Debut
  if (debut <= 10) n += `exploded onto the ${chartName} at <strong>#${debut}</strong> on ${debutDate}`;
  else if (debut <= 40) n += `entered the ${chartName} at a strong <strong>#${debut}</strong> on ${debutDate}`;
  else n += `debuted on the ${chartName} at <strong>#${debut}</strong> on ${debutDate}`;

  // Rise to peak
  if (peakPos === 1) {
    if (weeksToPeak === 1) n += ` and debuted at the summit`;
    else if (weeksToPeak <= 4) n += `, rocketing to <span class="gld">#1</span> in just ${weeksToPeak} weeks`;
    else if (weeksToPeak <= 8) n += `, climbing to <span class="gld">#1</span> in ${weeksToPeak} weeks`;
    else n += `, taking a steady ${weeksToPeak}-week climb to <span class="gld">#1</span>`;

    if (weeksAtPeak > 1) n += `, where it held the top spot for <strong>${weeksAtPeak} weeks</strong>`;
    else n += ` for a single week`;
  } else if (peakPos <= 10) {
    if (weeksToPeak <= 4) n += `, quickly rising to a peak of <strong>#${peakPos}</strong>`;
    else n += `, reaching a peak of <strong>#${peakPos}</strong> in week ${weeksToPeak}`;
    if (weeksAtPeak > 1) n += ` (${weeksAtPeak} weeks at peak)`;
  } else if (peakPos <= 40) {
    n += ` and peaked at <strong>#${peakPos}</strong>`;
  } else {
    n += ` and reached <strong>#${peakPos}</strong>`;
  }

  n += '. ';

  // Total run
  const wks = maxWks || weeks.length;
  if (wks >= 30) n += `With an impressive <strong>${wks}-week run</strong> on the chart, ${isAlbum ? 'the album' : 'it'} proved to have remarkable staying power.`;
  else if (wks >= 20) n += `${isAlbum ? 'The album' : 'The song'} spent a solid <strong>${wks} weeks</strong> on the chart.`;
  else if (wks >= 10) n += `It charted for <strong>${wks} weeks</strong>.`;
  else n += `It spent ${wks} weeks on the chart.`;

  // Biggest jump
  if (biggestJump >= 20 && jumpWeek) {
    n += ` Its biggest leap was a ${biggestJump}-position jump in week ${jumpWeek + 1}.`;
  }

  return `<div class="narrative"><p>${n}</p></div>`;
}

function artistNarrative(name, hl, n1, t10, totalWks, minY, maxY, isAlbum) {
  if (!hl || hl.length === 0) return '';
  const span = maxY - minY;
  const chartName = isAlbum ? 'Billboard 200' : 'Hot 100';
  const itemWord = isAlbum ? 'albums' : 'songs';
  const singleItem = isAlbum ? 'album' : 'chart entry';

  let n = `<span class="gld">${name}</span> `;

  if (span === 0) {
    n += `appeared on the ${chartName} in <strong>${minY}</strong>`;
  } else if (span <= 3) {
    n += `had a concentrated chart presence from <strong>${minY} to ${maxY}</strong>`;
  } else {
    n += `charted on the ${chartName} across <strong>${span} years</strong> (${minY}‚Äì${maxY})`;
  }

  if (hl.length === 1) {
    n += ` with a single ${singleItem}`;
  } else {
    n += `, placing <strong>${hl.length} ${itemWord}</strong> on the chart`;
  }

  if (n1 > 0) {
    const no1items = hl.filter(h => h.peak === 1);
    if (n1 === 1) {
      n += `, including the #1 ${isAlbum ? 'album' : 'hit'} <strong>"${no1items[0].title}"</strong>`;
    } else if (n1 === 2) {
      n += `, with two chart-toppers: <strong>"${no1items[0].title}"</strong> and <strong>"${no1items[1].title}"</strong>`;
    } else {
      n += `, with an impressive <strong>${n1} #1 ${isAlbum ? 'albums' : 'hits'}</strong>`;
    }
  }
  n += '. ';

  if (t10 > n1 && t10 >= 3) {
    n += `${t10} of their ${itemWord} reached the top 10. `;
  }

  if (n1 === 0) {
    const best = hl.reduce((a, b) => a.peak <= b.peak ? a : b);
    n += `Their biggest ${isAlbum ? 'album' : 'hit'} was <strong>"${best.title}"</strong>, peaking at <strong>#${best.peak}</strong>. `;
  }

  if (totalWks >= 200) {
    n += `Across all entries, they accumulated a remarkable <strong>${totalWks} total weeks</strong> on the chart.`;
  } else if (totalWks >= 50) {
    n += `They spent a combined <strong>${totalWks} weeks</strong> on the chart.`;
  }

  if (hl.length >= 3 && span >= 5) {
    const first = hl[0], last = hl[hl.length - 1];
    n += ` Their chart journey began with <strong>"${first.title}"</strong> in ${first.firstDate ? first.firstDate.substring(0,4) : '?'} and their last entry in this period was <strong>"${last.title}"</strong> in ${last.firstDate ? last.firstDate.substring(0,4) : '?'}.`;
  }

  return `<div class="narrative"><p>${n}</p></div>`;
}

// ‚îÄ‚îÄ‚îÄ SONG ENRICHMENT (async narrative enhancement) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _songEnrichment = null;

function updateSongEnrichment(field, data) {
  if (!_songEnrichment) return;
  _songEnrichment[field] = data;
  renderSongEnrichment();
}

function renderSongEnrichment() {
  const el = document.getElementById('songEnrichment');
  if (!el || !_songEnrichment) return;

  const e = _songEnrichment;
  const parts = [];

  // Credits line
  if (e.credits) {
    const { writers, producers } = e.credits;
    if (writers.length > 0) {
      const writerStr = writers.length <= 3 ? writers.join(writers.length === 2 ? ' and ' : ', ') : writers.slice(0, 2).join(', ') + ', and others';
      let creditLine = `Written by ${writerStr}`;
      if (producers.length > 0) {
        const writerSet = new Set(writers.map(w => w.toLowerCase()));
        const sameAsWriters = producers.every(p => writerSet.has(p.toLowerCase()));
        if (sameAsWriters && producers.length === writers.length) {
          creditLine += producers.length === 1 ? `, who also produced the track` : `, who also produced`;
        } else if (producers.length > 0) {
          const prodStr = producers.length <= 2 ? producers.join(' and ') : producers[0] + ' and others';
          creditLine += ` and produced by ${prodStr}`;
        }
      }
      parts.push(creditLine);
    } else if (producers.length > 0) {
      const prodStr = producers.length <= 2 ? producers.join(' and ') : producers[0] + ' and others';
      parts.push(`Produced by ${prodStr}`);
    }
  }

  // Album context
  if (e.albumInfo && e.albumInfo.title) {
    const a = e.albumInfo;
    let albumLine = `the single was featured on <strong>${a.title}</strong>`;
    if (a.peak > 0 && a.peak <= 40) albumLine += `, which reached <strong>#${a.peak}</strong> on the Billboard 200`;
    else if (a.peak > 40) albumLine += ` (Billboard 200: #${a.peak})`;
    parts.push(albumLine);
  }

  // Other chart peaks
  if (e.chartPeaks && e.chartPeaks.length > 0) {
    const peaks = e.chartPeaks;
    const chartName = chartType === 'billboard200' ? 'Billboard 200' : 'Hot 100';
    if (peaks.length === 1) {
      const p = peaks[0];
      const verb = p.peak === 1 ? 'topping' : p.peak <= 10 ? `reaching <strong>#${p.peak}</strong> on` : `peaking at #${p.peak} on`;
      parts.push(`beyond the ${chartName}, the song also made an impact, ${verb} the <strong>${p.chart}</strong>`);
    } else if (peaks.length <= 4) {
      const chartStrs = peaks.map(p => {
        if (p.peak === 1) return `<strong>#1</strong> on the ${p.chart}`;
        return `<strong>#${p.peak}</strong> on the ${p.chart}`;
      });
      const joined = chartStrs.length === 2 ? chartStrs.join(' and ') : chartStrs.slice(0, -1).join(', ') + ', and ' + chartStrs[chartStrs.length - 1];
      parts.push(`the song's reach extended to ${joined}`);
    } else {
      const top = peaks.slice(0, 3);
      const topStrs = top.map(p => `#${p.peak} ${p.chart}`);
      parts.push(`it charted on ${peaks.length} other Billboard charts, including ${topStrs.join(', ')}`);
    }
  }

  if (parts.length === 0) { el.innerHTML = ''; return; }

  // Combine parts into flowing text
  let text = '';
  if (parts.length === 1) {
    text = parts[0] + '.';
  } else if (parts.length === 2) {
    text = parts[0] + '. ' + parts[1].charAt(0).toUpperCase() + parts[1].slice(1) + '.';
  } else {
    text = parts[0] + '; ' + parts[1] + '. ' + parts[2].charAt(0).toUpperCase() + parts[2].slice(1) + '.';
  }
  text = text.charAt(0).toUpperCase() + text.slice(1);

  el.innerHTML = `<p>${text}</p>`;
}

// ‚îÄ‚îÄ‚îÄ SONGWRITER/PRODUCER CREDITS (via MusicBrainz) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const songwriterCache = {};

async function fetchSongwriterCredits(name, elementId) {
  const el = document.getElementById(elementId);
  if (!el) return;
  if (songwriterCache[name]) { renderSongwriterCredits(el, name, songwriterCache[name]); return; }

  el.innerHTML = `<div class="sw-section"><div class="sw-title">‚úçÔ∏è Songwriter & Producer Credits</div><div class="sw-status">Searching MusicBrainz...</div></div>`;

  try {
    // 1. Search MusicBrainz for the artist
    await sleep(1100);
    const searchUrl = `https://musicbrainz.org/ws/2/artist?query=${encodeURIComponent(name)}&fmt=json&limit=5`;
    const searchData = await (await fetch(searchUrl)).json();
    if (!searchData.artists || !searchData.artists.length) { el.innerHTML = ''; return; }

    const nameLow = name.toLowerCase();
    const mbArtist = searchData.artists.find(a => a.name && a.name.toLowerCase() === nameLow) ||
                     searchData.artists[0];
    const artistId = mbArtist.id;

    const norm = s => stripAccents(s).toLowerCase().replace(/[^a-z0-9]/g, '');
    const nameNorm = norm(name);

    // 2. Build chart data lookup: normalized title+artist ‚Üí entry
    const cache = activeCache();
    const chartByTitle = new Map(); // normTitle ‚Üí Map(normArtist ‚Üí entry)

    for (const [date, entries] of Object.entries(cache)) {
      if (!Array.isArray(entries)) continue;
      for (const e of entries) {
        if (!e || !e.title || !e.artist) continue;
        const tKey = norm(e.title);
        const aKey = norm(e.artist);
        if (!chartByTitle.has(tKey)) chartByTitle.set(tKey, new Map());
        const byArtist = chartByTitle.get(tKey);
        if (!byArtist.has(aKey)) {
          byArtist.set(aKey, { title: e.title, artist: e.artist, peak: parseInt(e.peak) || 99, weeks: parseInt(e.weeks) || 0, firstDate: date });
        } else {
          const ex = byArtist.get(aKey);
          const p = parseInt(e.peak) || 99;
          if (p < ex.peak) ex.peak = p;
          const w = parseInt(e.weeks) || 0;
          if (w > ex.weeks) ex.weeks = w;
          if (date < ex.firstDate) ex.firstDate = date;
        }
      }
    }

    // 3. Browse RECORDINGS linked to this artist (includes producer/writer credits)
    //    Each recording has artist-credit = the performing artist
    const matches = [];
    const seenSong = new Set();
    const confirmedArtists = new Set(); // normalized names of artists they worked with

    let recOffset = 0;
    while (recOffset < 500) {
      await sleep(1100);
      const statusEl = el.querySelector('.sw-status');
      if (statusEl) statusEl.textContent = `Scanning recordings... (${recOffset} checked)`;

      const recUrl = `https://musicbrainz.org/ws/2/recording?artist=${artistId}&limit=100&offset=${recOffset}&fmt=json`;
      const recData = await (await fetch(recUrl)).json();
      if (!recData.recordings || !recData.recordings.length) break;

      for (const rec of recData.recordings) {
        if (!rec.title || !rec['artist-credit']) continue;
        const recTitleNorm = norm(rec.title);

        // Extract performing artist(s) from artist-credit
        const perfArtists = rec['artist-credit']
          .filter(ac => ac.artist)
          .map(ac => ({ name: ac.artist.name, norm: norm(ac.artist.name) }));

        // Skip if this person is the performing artist
        if (perfArtists.some(a => a.norm === nameNorm)) continue;

        // Record all performing artists as confirmed collaborators
        for (const a of perfArtists) confirmedArtists.add(a.norm);

        // Try to match against chart data
        const chartCandidates = chartByTitle.get(recTitleNorm);
        if (!chartCandidates) continue;

        // Build full performing artist string for matching
        const fullPerfNorm = perfArtists.map(a => a.norm).join('');

        for (const [artKey, entry] of chartCandidates) {
          if (artKey === nameNorm) continue;

          // Match: chart artist matches recording's performing artist
          const artistMatch = perfArtists.some(a =>
            a.norm === artKey ||
            (a.norm.length >= 5 && artKey.includes(a.norm.substring(0, Math.min(8, a.norm.length)))) ||
            (artKey.length >= 5 && a.norm.includes(artKey.substring(0, Math.min(8, artKey.length))))
          ) || (fullPerfNorm.length >= 5 && artKey.includes(fullPerfNorm.substring(0, 6))) ||
               (artKey.length >= 5 && fullPerfNorm.includes(artKey.substring(0, 6)));

          if (!artistMatch) continue;

          const matchKey = entry.title + '|||' + entry.artist;
          if (seenSong.has(matchKey)) continue;
          seenSong.add(matchKey);

          matches.push({
            title: entry.title, artist: entry.artist,
            peak: entry.peak, weeks: entry.weeks,
            roles: ['Writer/Producer'],
            year: entry.firstDate ? parseInt(entry.firstDate.substring(0, 4)) : 0
          });
        }
      }

      if (recData['recording-count'] && recOffset + 100 >= recData['recording-count']) break;
      recOffset += 100;
    }

    // 4. Browse WORKS to catch songwriter credits not linked via recordings
    //    Only accept matches where chart artist is a confirmed collaborator
    const statusElW = el.querySelector('.sw-status');
    if (statusElW) statusElW.textContent = `Checking songwriter credits...`;

    let workOffset = 0;
    while (workOffset < 500) {
      await sleep(1100);
      const statusEl2 = el.querySelector('.sw-status');
      if (statusEl2) statusEl2.textContent = `Checking songwriter credits... (${workOffset} works)`;

      const worksUrl = `https://musicbrainz.org/ws/2/work?artist=${artistId}&limit=100&offset=${workOffset}&fmt=json`;
      const worksData = await (await fetch(worksUrl)).json();
      if (!worksData.works || !worksData.works.length) break;

      for (const work of worksData.works) {
        const workNorm = norm(work.title || '');
        if (!workNorm || workNorm.length < 4) continue;

        const chartCandidates = chartByTitle.get(workNorm);
        if (!chartCandidates) continue;

        for (const [artKey, entry] of chartCandidates) {
          if (artKey === nameNorm) continue;

          const matchKey = entry.title + '|||' + entry.artist;
          if (seenSong.has(matchKey)) continue;

          // Only accept if this artist is a confirmed collaborator from recordings
          const isConfirmed = confirmedArtists.has(artKey) ||
            [...confirmedArtists].some(c =>
              (c.length >= 5 && artKey.includes(c.substring(0, Math.min(8, c.length)))) ||
              (artKey.length >= 5 && c.includes(artKey.substring(0, Math.min(8, artKey.length))))
            );
          if (!isConfirmed) continue;

          seenSong.add(matchKey);
          matches.push({
            title: entry.title, artist: entry.artist,
            peak: entry.peak, weeks: entry.weeks,
            roles: ['Writer'],
            year: entry.firstDate ? parseInt(entry.firstDate.substring(0, 4)) : 0
          });
        }
      }

      if (worksData['work-count'] && workOffset + 100 >= worksData['work-count']) break;
      workOffset += 100;
    }

    matches.sort((a, b) => a.peak - b.peak || b.weeks - a.weeks);
    songwriterCache[name] = matches;
    renderSongwriterCredits(el, name, matches);

  } catch(e) {
    console.error('Songwriter credits error:', e);
    el.innerHTML = `<div class="sw-section"><div class="sw-title">‚úçÔ∏è Songwriter & Producer Credits</div><div class="sw-status" style="color:var(--down)">Error: ${e.message || e}</div></div>`;
  }
}

function renderSongwriterCredits(el, name, matches) {
  if (!matches || !matches.length) {
    el.innerHTML = `<div class="sw-section"><div class="sw-title">‚úçÔ∏è Songwriter & Producer Credits</div><div class="sw-status">No charted songs found for other artists. Try loading more decades.</div></div>`;
    return;
  }

  const chartName = chartType === 'billboard200' ? 'Billboard 200' : 'Hot 100';
  const n1 = matches.filter(m => m.peak === 1).length;
  const t10 = matches.filter(m => m.peak <= 10).length;
  const statParts = [`${matches.length} charted song${matches.length !== 1 ? 's' : ''}`];
  if (n1 > 0) statParts.push(`${n1} #1${n1 !== 1 ? 's' : ''}`);
  else if (t10 > 0) statParts.push(`${t10} top 10`);

  let h = `<div class="sw-section">
    <div class="sw-header">
      <div class="sw-title">‚úçÔ∏è Songwriter & Producer Credits</div>
      <div class="sw-subtitle">${statParts.join(' ¬∑ ')} on the ${chartName}</div>
    </div>
    <div class="sw-grid">`;

  for (const m of matches) {
    const peakCls = m.peak === 1 ? 'peak-1' : m.peak <= 10 ? 'peak-top10' : m.peak <= 40 ? 'peak-top20' : 'peak-deep';
    const isNo1 = m.peak === 1;
    h += `<div class="sw-card${isNo1 ? ' sw-card-gold' : ''}" onclick="showSong('${esc(m.title)}','${esc(m.artist)}')">
      <div class="sw-card-rank ${peakCls}">#${m.peak}</div>
      <div class="sw-card-info">
        <div class="sw-card-title">${m.title}</div>
        <div class="sw-card-artist">${m.artist}${m.year ? ` ¬∑ ${m.year}` : ''}</div>
        <div class="sw-card-roles">${m.roles.join(' ¬∑ ')}</div>
      </div>
      <div class="sw-card-weeks">${m.weeks}<span>wks</span></div>
    </div>`;
  }

  h += `</div><div class="sw-source">via MusicBrainz</div></div>`;
  el.innerHTML = h;
}

// ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function switchView(v) {
  const currentView = document.querySelector('.view.active');
  if (currentView && v !== 'song') {
    previousView = currentView.id.replace('view-', '');
  } else if (currentView && v === 'song') {
    previousView = currentView.id.replace('view-', '');
  }
  document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
  document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('view-' + v).classList.add('active');
  const navBtn = document.querySelector(`.nav-btn[data-view="${v}"]`);
  if (navBtn) navBtn.classList.add('active');
  if (v === 'search') setTimeout(() => document.getElementById('searchInput').focus(), 100);
  if (v === 'artist') setTimeout(() => document.getElementById('artistInput').focus(), 100);
  // Restore BB200 controls when returning to weekly view in BB200 mode
  if (v === 'weekly' && chartType === 'billboard200' && b200Loaded) {
    document.getElementById('weeklyControls').style.display = 'none';
    document.getElementById('b200Controls').style.display = 'block';
    document.getElementById('b200StartupInfo').style.display = 'block';
    document.getElementById('startupInfo').style.display = 'none';
  }
}

function renderEntry(e, i, showDate) {
  const r = e.rank, cls = r === 1 ? 'gold' : r <= 3 ? 'silver' : r <= 10 ? 'top10' : 'normal';
  const lw = e.lastWeek;
  let mi = 'NEW', mc = 'new';
  if (lw) {
    const diff = lw - r;
    if (diff > 0) { mi = '‚ñ≤' + diff; mc = 'up'; }
    else if (diff < 0) { mi = '‚ñº' + Math.abs(diff); mc = 'down'; }
    else { mi = '‚Äî'; mc = 'same'; }
  }
  const extraCls = r === 1 ? ' no1-entry' : r <= 3 ? ' top3-entry' : '';
  const crownHtml = r === 1 ? '<div class="no1-crown">üëë #1 THIS WEEK</div>' : '';
  return `<div class="chart-entry${extraCls}" style="animation-delay:${Math.min(i,20)*20}ms">
    <div class="rank-badge ${cls}">${r || '‚Äî'}</div>
    <div class="entry-info">
      <div class="entry-title clickable" onclick="searchFor('${esc(e.title)}','${esc(e.artist)}')">${e.title || ''}</div>
      <div class="entry-meta"><span class="entry-artist" onclick="goToArtist('${esc(e.artist)}')">${e.artist || ''}</span>${crownHtml}</div>
    </div>
    <div class="entry-stats">
      ${lw ? `<div class="stat-col"><div class="stat-header">LW</div><div class="stat-val">${lw}</div></div>` : '<div class="stat-col"><div class="stat-header">LW</div><div class="stat-val">‚Äî</div></div>'}
      ${e.peak ? `<div class="stat-col"><div class="stat-header">PK</div><div class="stat-val">${e.peak}</div></div>` : ''}
      ${e.weeks ? `<div class="stat-col"><div class="stat-header">WK</div><div class="stat-val">${e.weeks}</div></div>` : ''}
      <div class="move-badge ${mc}">${mi}</div>
    </div>
    ${showDate && e.date ? `<div class="chart-badge">${e.date.substring(0,4)}</div>` : ''}</div>`;
}

function esc(s) { return (s || '').replace(/'/g, "\\'").replace(/"/g, '&quot;'); }
function fmtDate(s) { if (!s || s.length < 10) return s || ''; const d = new Date(s + 'T12:00:00'); return d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }); }
function validWeekCount() {
  const cache = activeCache();
  return Object.keys(cache).filter(d => Array.isArray(cache[d]) && cache[d].length > 0).length;
}

function updateStats() {
  const cache = activeCache();
  const dates = activeDates();
  const w = validWeekCount();
  const t = Object.values(cache).reduce((s, e) => s + (Array.isArray(e) ? e.length : 0), 0);
  const label = chartType === 'hot100' ? 'Hot 100' : 'Billboard 200';
  const range = chartType === 'hot100' ? '1958‚Äì2019' : (filteredAlbumDates.length ? filteredAlbumDates[0].substring(0,4) + '‚Äì' + filteredAlbumDates[filteredAlbumDates.length-1].substring(0,4) : '');
  document.getElementById('footerStats').textContent = `${label}: ${w} weeks loaded ‚Ä¢ ${t.toLocaleString()} entries${dates.length ? ' ‚Ä¢ ' + dates.length + ' available (' + range + ')' : ''}`;
}

// ‚îÄ‚îÄ‚îÄ DATA PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function toggleDataPanel() {
  const panel = document.getElementById('dataPanel');
  panel.classList.toggle('open');
}

function updateDataBadge() {
  const badge = document.getElementById('dataBadge');
  if (!badge) return;
  const n = validWeekCount();
  badge.textContent = n > 0 ? n + ' weeks saved' : 'no data yet';
  badge.style.color = n > 0 ? 'var(--up)' : 'var(--text-faint)';
  badge.style.background = n > 0 ? 'rgba(74,222,128,.1)' : 'rgba(255,255,255,.05)';
}

// ‚îÄ‚îÄ‚îÄ DECADE NAV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const decadeRanges = {
  '60s': [1958,1969], '70s': [1970,1979], '80s': [1980,1989],
  '90s': [1990,1999], '00s': [2000,2009], '10s': [2010,2019]
};
let activeDecade = null;

function selectDecade(startYear, label) {
  const drawer = document.getElementById('yearDrawer');
  const btns = document.querySelectorAll('.decade-nav-btn');

  // Toggle same decade off
  if (activeDecade === label) {
    activeDecade = null;
    drawer.classList.remove('open');
    btns.forEach(b => b.classList.remove('active'));
    return;
  }

  activeDecade = label;
  btns.forEach(b => {
    b.classList.toggle('active', b.textContent.trim() === label);
  });

  const range = decadeRanges[label];
  const years = [];
  for (let y = range[0]; y <= range[1]; y++) {
    if (filteredDates.some(d => d.startsWith(String(y)))) years.push(y);
  }

  drawer.innerHTML = years.map(y =>
    `<button class="year-pill" onclick="jumpToYear(${y});highlightYearPill(this)">${y}</button>`
  ).join('');
  drawer.classList.add('open');
}

function highlightYearPill(el) {
  document.querySelectorAll('.year-pill').forEach(p => p.classList.remove('active'));
  el.classList.add('active');
}

let activeAlbumDecade = null;

function selectAlbumDecade(startYear, label) {
  const drawer = document.getElementById('b200YearDrawer');
  const btns = document.querySelectorAll('#b200DecadeNav .decade-nav-btn');

  if (activeAlbumDecade === label) {
    activeAlbumDecade = null;
    drawer.classList.remove('open');
    btns.forEach(b => b.classList.remove('active'));
    return;
  }

  activeAlbumDecade = label;
  btns.forEach(b => b.classList.toggle('active', b.textContent.trim() === label));

  const endYear = startYear + (label === '60s' ? 9 : 9);
  const years = [];
  for (let y = startYear; y <= startYear + 9; y++) {
    if (filteredAlbumDates.some(d => d.startsWith(String(y)))) years.push(y);
  }

  drawer.innerHTML = years.map(y =>
    `<button class="year-pill" onclick="jumpToAlbumYear(${y});highlightYearPill(this)">${y}</button>`
  ).join('');
  drawer.classList.add('open');
}

// ‚îÄ‚îÄ‚îÄ SKELETON LOADING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderSkeleton(count) {
  count = count || 10;
  let h = '<div class="chart-list">';
  for (let i = 0; i < count; i++) {
    h += `<div class="skeleton-entry">
      <div class="skeleton-circle skeleton"></div>
      <div class="skeleton-lines">
        <div class="skeleton-line w60 skeleton"></div>
        <div class="skeleton-line w35 skeleton"></div>
      </div>
      <div class="skeleton-stats">
        <div class="skeleton-stat skeleton"></div>
        <div class="skeleton-stat skeleton"></div>
        <div class="skeleton-stat skeleton"></div>
      </div>
    </div>`;
    if (i < count - 1) h += '<div class="chart-divider"></div>';
  }
  h += '</div>';
  return h;
}

// ‚îÄ‚îÄ‚îÄ HASH ROUTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let hashNavigating = false; // prevent loops

function updateHash(viewType, param1, param2) {
  if (hashNavigating) return;
  let hash = '';
  const ct = chartType === 'billboard200' ? 'b200' : 'hot100';

  if (viewType === 'song' && param1 && param2) {
    hash = `#/song/${encodeURIComponent(param1)}/${encodeURIComponent(param2)}`;
  } else if (viewType === 'artist' && param1) {
    hash = `#/artist/${encodeURIComponent(param1)}`;
  } else if (currentDate) {
    hash = `#/${ct}/${currentDate}`;
  }

  if (hash && location.hash !== hash) {
    history.pushState(null, '', hash);
  }
}

function parseHash() {
  const hash = location.hash;
  if (!hash || hash.length < 3) return null;

  const parts = hash.substring(2).split('/'); // strip '#/'
  if (parts[0] === 'hot100' && parts[1]) {
    return { type: 'chart', chart: 'hot100', date: parts[1] };
  }
  if (parts[0] === 'b200' && parts[1]) {
    return { type: 'chart', chart: 'billboard200', date: parts[1] };
  }
  if (parts[0] === 'artist' && parts[1]) {
    return { type: 'artist', name: decodeURIComponent(parts[1]) };
  }
  if (parts[0] === 'song' && parts[1] && parts[2]) {
    return { type: 'song', title: decodeURIComponent(parts[1]), artist: decodeURIComponent(parts[2]) };
  }
  return null;
}

async function navigateToHash() {
  const route = parseHash();
  if (!route) return;

  hashNavigating = true;
  try {
    if (route.type === 'chart') {
      // Switch chart type if needed
      if (route.chart !== chartType) {
        switchChartType(route.chart);
        // Wait for B200 to load if switching to it
        if (route.chart === 'billboard200' && !b200Loaded) {
          hashNavigating = false;
          return; // B200 not loaded yet, can't navigate
        }
      }
      // Navigate to the date
      const dates = route.chart === 'billboard200' ? filteredAlbumDates : filteredDates;
      if (dates.includes(route.date)) {
        switchView('weekly');
        if (route.chart === 'billboard200') {
          loadAlbumChartWeek(route.date);
        } else {
          loadChartWeek(route.date);
        }
      }
    } else if (route.type === 'artist') {
      document.getElementById('artistInput').value = route.name;
      switchView('artist');
      showArtist(route.name);
    } else if (route.type === 'song') {
      showSong(route.title, route.artist);
    }
  } finally {
    hashNavigating = false;
  }
}

window.addEventListener('popstate', () => navigateToHash());

function shareContent(title, text, btnId) {
  const url = location.href;
  const shareData = { title, text, url };

  // Try native Web Share API first (mobile share sheets)
  if (navigator.share) {
    navigator.share(shareData).catch(() => {});
    return;
  }

  // Desktop fallback: copy to clipboard
  navigator.clipboard.writeText(url).then(() => {
    flashShareBtn(btnId, '‚úì Link copied!');
  }).catch(() => {
    prompt('Copy this link:', url);
  });
}

function flashShareBtn(btnId, msg) {
  const btn = document.getElementById(btnId);
  if (!btn) return;
  const orig = btn.innerHTML;
  btn.innerHTML = msg;
  btn.classList.add('copied');
  setTimeout(() => { btn.innerHTML = orig; btn.classList.remove('copied'); }, 2200);
}

function shareChart() {
  const label = chartLabel();
  const date = currentDate ? fmtDate(currentDate) : 'chart week';
  shareContent(
    `${label} ‚Äî ${date}`,
    `Check out the ${label} chart for the week of ${date}`,
    chartType === 'billboard200' ? 'shareBtnB200' : 'shareBtnH100'
  );
}

function shareSong(title, artist) {
  shareContent(
    `${title} ‚Äî ${artist}`,
    `${title} by ${artist} ‚Äî chart history on ChartVault`,
    'shareSongBtn'
  );
}

function shareArtist(name) {
  shareContent(
    `${name} ‚Äî Chart History`,
    `${name}'s chart history on ChartVault`,
    'shareArtistBtn'
  );
}

// ‚îÄ‚îÄ‚îÄ KEYBOARD NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

document.addEventListener('keydown', function(e) {
  // Only when not focused on an input
  const tag = document.activeElement ? document.activeElement.tagName : '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

  const activeView = document.querySelector('.view.active');
  if (!activeView) return;

  // Song/album detail view: arrow keys navigate artist entries
  if (activeView.id === 'view-song') {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      if (_navPrev) showSong(_navPrev.title, _navPrev.artist);
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      if (_navNext) showSong(_navNext.title, _navNext.artist);
    }
    return;
  }

  // Weekly view: arrow keys navigate chart weeks
  if (activeView.id !== 'view-weekly') return;

  if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    e.preventDefault();
    if (chartType === 'billboard200') prevAlbumWeek(); else prevWeek();
  } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    e.preventDefault();
    if (chartType === 'billboard200') nextAlbumWeek(); else nextWeek();
  }
});

// ‚îÄ‚îÄ‚îÄ START ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Swipe navigation for song/album detail
let _swipeX = 0;
document.addEventListener('touchstart', e => { _swipeX = e.touches[0].clientX; }, { passive: true });
document.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - _swipeX;
  if (Math.abs(dx) < 80) return; // too short
  const v = document.querySelector('.view.active');
  if (!v || v.id !== 'view-song') return;
  if (dx > 0 && _navPrev) showSong(_navPrev.title, _navPrev.artist);
  else if (dx < 0 && _navNext) showSong(_navNext.title, _navNext.artist);
}, { passive: true });

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
